"""
DO NOT EDIT THIS FILE!!
This file is automatically generated by the process_schemas.py program
in the scripts directory. It is not intended to be edited directly. If
you need to update the GA4GH protocol classes, please run the script
on the appropriate schema version.
"""
from protocol import ProtocolElement
from protocol import SearchRequest
from protocol import SearchResponse

import avro.schema

version = '0.6'


class Allele(ProtocolElement):
    """
    Alleles are the key component of the "allelic" model of variation:
    they are single objects that are present in some copy number.  An
    Allele is a contiguous piece of sequence that we will want to say
    is present (in general at some copy number) or absent in a sample.
    Very often it will just be a single Segment covering the entirety
    of a novel Sequence, but it is also common for it to be a mix of
    Segments on reference and novel Sequences, or in general to be any
    contiguous path through the augmented sequence graph.  Alleles
    belong to VariantSets. Alleles can also be used to represent the
    reference and alternate alleles of Variants.  Note that Paths
    cannot follow Joins not represented in the augmented sequence
    graph. For example, if  an Allele that spans a novel deletion is
    required, a new Join should exist to describe that deletion,
    available through searchJoins().
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name": "Allele",
"fields": [{"doc": "", "type": "string", "name": "id"}, {"doc": "",
"type": "string", "name": "variantSetId"}, {"doc": "", "type": {"doc":
"", "type": "record", "name": "Path", "fields": [{"default": [],
"doc": "", "type": {"items": {"doc": "", "type": "record", "name":
"Segment", "fields": [{"doc": "", "type": {"doc": "", "type":
"record", "name": "Side", "fields": [{"doc": "", "type": {"doc": "",
"type": "record", "name": "Position", "fields": [{"default": null,
"doc": "", "type": ["null", "string"], "name": "sequenceId"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"referenceName"}, {"doc": "", "type": "long", "name": "position"}]},
"name": "base"}, {"doc": "", "type": {"symbols": ["NEG_STRAND",
"POS_STRAND"], "doc": "", "type": "enum", "name": "Strand"}, "name":
"strand"}]}, "name": "start"}, {"doc": "", "type": "long", "name":
"length"}]}, "type": "array"}, "name": "segments"}]}, "name":
"path"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "id",
        "path",
        "variantSetId",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'path': Path,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'path': Path,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'id', 'path', 'variantSetId'
    ]

    def __init__(self, **kwargs):
        self.id = kwargs.get(
            'id', None)
        """
        The ID of this Allele. If this Allele is one Segment
        consisting of   the entirety of a Sequence, this is equal to
        the ID of that Sequence.
        """
        self.path = kwargs.get(
            'path', None)
        """
        The ordered and oriented Segments of DNA that this Allele
        represents.    Segments on this Path are on either Reference
        Sequences, or   Sequences associated with this VariantSet.
        Both types of Sequences are   available through the
        searchSequences() and getSequence() API calls.
        """
        self.variantSetId = kwargs.get(
            'variantSetId', None)
        """
        The ID of the variant set this allele belongs to.
        """


class AlleleCall(ProtocolElement):
    """
    An AlleleCall represents the determination of the copy number of a
    particular Allele, possibly within a certain Variant.  It may
    include associated information such as quality and phasing.  The
    Allele copy numbers described by an AlleleCall must be consistent
    with those implied by the genotypes of any Calls in the same
    CallSet. If a server supports "graph" mode, it must provide
    Variant-associated AlleleCalls for any Variant with a Call in the
    CallSet.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"AlleleCall", "fields": [{"doc": "", "type": "string", "name":
"callSetId"}, {"doc": "", "type": "string", "name": "alleleId"},
{"doc": "", "type": ["null", "string"], "name": "variantId"}, {"doc":
"", "type": "double", "name": "totalCopies"}, {"doc": "", "type":
{"items": "string", "type": "array"}, "name": "phaseset"}, {"default":
{}, "doc": "", "type": {"values": {"items": "string", "type":
"array"}, "type": "map"}, "name": "info"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "alleleId",
        "callSetId",
        "phaseset",
        "totalCopies",
        "variantId",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'alleleId', 'callSetId', 'info', 'phaseset', 'totalCopies',
        'variantId'
    ]

    def __init__(self, **kwargs):
        self.alleleId = kwargs.get(
            'alleleId', None)
        """
        The ID of the Allele that this AlleleCall is calling the copy
        number of.
        """
        self.callSetId = kwargs.get(
            'callSetId', None)
        """
        The ID of the call set this AlleleCall belongs to.
        """
        self.info = kwargs.get(
            'info', {})
        """
        A map of additional allele call information.
        """
        self.phaseset = kwargs.get(
            'phaseset', None)
        """
        Defines the phasing of the copies of this Allele. Each entry
        is associated   with an instance of this AlleleCall's Allele.
        Allele instances that are   associated with the same phaseset
        string occur on the same molecule of DNA.    The number of
        entries should not exceed totalCopies.
        """
        self.totalCopies = kwargs.get(
            'totalCopies', None)
        """
        Gives the called copy number of the Allele. If variantId is
        null, this   gives the total copy number of the Allele,
        including copies associated with   Variants. Otherwise, it is
        the copy number of this Allele in the specified   Variant, and
        must agree with the genotype of the Call for that   Variant,
        if any.
        """
        self.variantId = kwargs.get(
            'variantId', None)
        """
        The ID of the Variant that this AlleleCall belongs to.    The
        specified Variant must have this AlleleCall's Allele as an
        option.    Only one AlleleCall may be associated with a
        particular Variant-Allele   combination in a particular
        CallSet. So, one AlleleCall for this Allele   may have a null
        variantId, and one additional AlleleCall can use this   Allele
        for each Variant the Allele appears in.
        """


class Analysis(ProtocolElement):
    """
    An analysis contains an interpretation of one or several
    experiments. (e.g. SNVs, copy number variations, methylation
    status) together with information about the methodology used.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"Analysis", "fields": [{"doc": "", "type": "string", "name": "id"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"name"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "description"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "recordCreateTime"}, {"doc": "", "type": "string",
"name": "recordUpdateTime"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "type"}, {"default": [], "doc": "",
"type": {"items": "string", "type": "array"}, "name": "software"},
{"default": {}, "doc": "", "type": {"values": {"items": "string",
"type": "array"}, "type": "map"}, "name": "info"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "id",
        "recordUpdateTime",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'description', 'id', 'info', 'name', 'recordCreateTime',
        'recordUpdateTime', 'software', 'type'
    ]

    def __init__(self, **kwargs):
        self.description = kwargs.get(
            'description', None)
        """
        A description of the analysis.
        """
        self.id = kwargs.get(
            'id', None)
        """
        The analysis UUID. This is globally unique.
        """
        self.info = kwargs.get(
            'info', {})
        """
        A map of additional analysis information.
        """
        self.name = kwargs.get(
            'name', None)
        """
        The name of the analysis.
        """
        self.recordCreateTime = kwargs.get(
            'recordCreateTime', None)
        """
        The time at which this record was created.    Format: ISO
        8601, YYYY-MM-DDTHH:MM:SS.SSS (e.g. 2015-02-10T00:03:42.123Z)
        """
        self.recordUpdateTime = kwargs.get(
            'recordUpdateTime', None)
        """
        The time at which this record was last updated.   Format: ISO
        8601, YYYY-MM-DDTHH:MM:SS.SSS (e.g. 2015-02-10T00:03:42.123Z)
        """
        self.software = kwargs.get(
            'software', [])
        """
        The software run to generate this analysis.
        """
        self.type = kwargs.get(
            'type', None)
        """
        The type of analysis.
        """


class Attributes(ProtocolElement):
    """
    Type defining a collection of attributes associated with various
    protocol   records.  Each attribute is a name that maps to an
    array of one or more   values.  Values can be strings, external
    identifiers, or ontology terms.   Values should be split into the
    array elements instead of using a separator   syntax that needs to
    parsed.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"Attributes", "fields": [{"default": {}, "type": {"values": {"items":
["string", {"doc": "", "type": "record", "name": "ExternalIdentifier",
"fields": [{"doc": "", "type": "string", "name": "database"}, {"doc":
"", "type": "string", "name": "identifier"}, {"doc": "", "type":
"string", "name": "version"}]}, {"doc": "", "type": "record", "name":
"OntologyTerm", "fields": [{"doc": "", "type": "string", "name":
"ontologySource"}, {"doc": "", "type": "string", "name": "id"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"name"}]}], "type": "array"}, "type": "map"}, "name": "vals"}], "doc":
""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'vals'
    ]

    def __init__(self, **kwargs):
        self.vals = kwargs.get(
            'vals', {})


class BeaconInformationResource(ProtocolElement):
    """
    BeaconInformationResource
    """
    _schemaSource = """
{"namespace": "org.ga4gh.beacon", "type": "record", "name":
"BeaconInformationResource", "fields": [{"doc": "", "type": "string",
"name": "id"}, {"doc": "", "type": "string", "name": "organization"},
{"doc": "", "type": "string", "name": "description"}, {"default": [],
"doc": "", "type": {"items": {"doc": "", "type": "record", "name":
"DataSetResource", "fields": [{"doc": "", "type": "string", "name":
"id"}, {"doc": "", "type": "string", "name": "reference"}, {"default":
null, "doc": "", "type": ["null", "string"], "name": "description"},
{"default": null, "doc": "", "type": ["null", {"doc": "", "type":
"record", "name": "DataSizeResource", "fields": [{"doc": "", "type":
"int", "name": "variants"}, {"doc": "", "type": "int", "name":
"samples"}]}], "name": "size"}, {"default": [], "doc": "", "type":
{"items": {"doc": "", "type": "record", "name": "DataUseResource",
"fields": [{"doc": "", "type": "string", "name": "category"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"description"}, {"default": [], "doc": "", "type": {"items": {"doc":
"", "type": "record", "name": "DataUseRequirementResource", "fields":
[{"doc": "", "type": "string", "name": "name"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "description"}]},
"type": "array"}, "name": "requirements"}]}, "type": "array"}, "name":
"data_use"}]}, "type": "array"}, "name": "datasets"}, {"doc": "",
"type": "string", "name": "api"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "homepage"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "email"}, {"default": null, "doc":
"", "type": ["null", "string"], "name": "auth"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "queries"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "api",
        "description",
        "id",
        "organization",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'datasets': DataSetResource,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'datasets': DataSetResource,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'api', 'auth', 'datasets', 'description', 'email', 'homepage',
        'id', 'organization', 'queries'
    ]

    def __init__(self, **kwargs):
        self.api = kwargs.get(
            'api', None)
        """
        Beacon API version supported.
        """
        self.auth = kwargs.get(
            'auth', None)
        """
        Auth type. Expected value is OAUTH2. Defaults to NONE.
        """
        self.datasets = kwargs.get(
            'datasets', [])
        """
        Datasets served by the beacon.
        """
        self.description = kwargs.get(
            'description', None)
        """
        Beacon description.
        """
        self.email = kwargs.get(
            'email', None)
        """
        An email address for contact.
        """
        self.homepage = kwargs.get(
            'homepage', None)
        """
        URL to the homepage for this beacon.
        """
        self.id = kwargs.get(
            'id', None)
        """
        (Unique) beacon ID. Recommended pattern:
        [organization]-[beacon] (no special characters).
        """
        self.organization = kwargs.get(
            'organization', None)
        """
        Name of the owning organization.
        """
        self.queries = kwargs.get(
            'queries', None)
        """
        Examples of interesting queries, e.g. a few queries
        demonstrating different types of responses.
        """


class BeaconResponseResource(ProtocolElement):
    """
    The response from the Beacon
    """
    _schemaSource = """
{"namespace": "org.ga4gh.beacon", "type": "record", "name":
"BeaconResponseResource", "fields": [{"doc": "", "type": "string",
"name": "beacon"}, {"doc": "", "type": {"doc": "", "type": "record",
"name": "QueryResource", "fields": [{"doc": "", "type": "string",
"name": "referenceBases"}, {"doc": "", "type": "string", "name":
"alternateBases"}, {"doc": "", "type": "string", "name":
"chromosome"}, {"doc": "", "type": "long", "name": "position"},
{"doc": "", "type": "string", "name": "reference"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "dataset"}]}, "name":
"query"}, {"doc": "", "type": {"doc": "", "type": "record", "name":
"ResponseResource", "fields": [{"doc": "", "type": "string", "name":
"exists"}, {"doc": "", "type": ["null", "double"], "name":
"frequency"}, {"default": null, "doc": "", "type": ["null", "int"],
"name": "observed"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "info"}, {"default": null, "doc": "", "type":
["null", {"doc": "", "type": "record", "name": "ErrorResource",
"fields": [{"doc": "", "type": "string", "name": "name"}, {"default":
null, "doc": "", "type": ["null", "string"], "name":
"description"}]}], "name": "err"}]}, "name": "response"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "beacon",
        "query",
        "response",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'query': QueryResource,
            'response': ResponseResource,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'query': QueryResource,
            'response': ResponseResource,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'beacon', 'query', 'response'
    ]

    def __init__(self, **kwargs):
        self.beacon = kwargs.get(
            'beacon', None)
        """
        Beacon ID
        """
        self.query = kwargs.get(
            'query', None)
        """
        Query
        """
        self.response = kwargs.get(
            'response', None)
        """
        Response
        """


class Call(ProtocolElement):
    """
    A Call represents the determination of genotype with respect to a
    particular Variant.  It may include associated information such as
    quality and phasing. For example, a call might assign a
    probability of 0.32 to the occurrence of a SNP named rs1234 in a
    call set with the name NA12345.  The genotypes described by Calls
    must be consistent with any AlleleCalls in the same CallSet. If a
    server supports "classic" mode, it must provide Calls for all
    Variants that have associated AlleleCalls in the CallSet.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name": "Call",
"fields": [{"doc": "", "type": ["null", "string"], "name":
"callSetId"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "callSetName"}, {"doc": "", "type": ["null", "string"],
"name": "variantId"}, {"default": [], "doc": "", "type": {"items":
"int", "type": "array"}, "name": "genotype"}, {"default": null, "doc":
"", "type": ["null", "string", {"items": "string", "type": "array"}],
"name": "phaseset"}, {"default": [], "doc": "", "type": {"items":
"double", "type": "array"}, "name": "genotypeLikelihood"}, {"default":
{}, "doc": "", "type": {"values": {"items": "string", "type":
"array"}, "type": "map"}, "name": "info"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "callSetId",
        "variantId",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'callSetId', 'callSetName', 'genotype', 'genotypeLikelihood',
        'info', 'phaseset', 'variantId'
    ]

    def __init__(self, **kwargs):
        self.callSetId = kwargs.get(
            'callSetId', None)
        """
        The ID of the call set this variant call belongs to.   If this
        field is not present, the ordering of the call sets from a
        SearchCallSetsRequest over this VariantSet is guaranteed to
        match   the ordering of the calls on this Variant.   The
        number of results will also be the same.
        """
        self.callSetName = kwargs.get(
            'callSetName', None)
        """
        The name of the call set this variant call belongs to.   If
        this field is not present, the ordering of the call sets from
        a   SearchCallSetsRequest over this VariantSet is guaranteed
        to match   the ordering of the calls on this Variant.   The
        number of results will also be the same.
        """
        self.genotype = kwargs.get(
            'genotype', [])
        """
        The genotype of this variant call.    A 0 value represents the
        reference allele of the associated Variant. Any   other value
        is a 1-based index into the alternate alleles of the
        associated   Variant.    If a variant had a referenceBases
        field of "T", an alternateBases   value of ["A", "C"], and the
        genotype was [2, 1], that would mean the call   represented
        the heterozygous value "CA" for this variant. If the genotype
        was instead [0, 1] the represented value would be "TA".
        Ordering of the   genotype values is important if the phaseset
        field is present.
        """
        self.genotypeLikelihood = kwargs.get(
            'genotypeLikelihood', [])
        """
        The genotype likelihoods for this variant call. Each array
        entry   represents how likely a specific genotype is for this
        call as   log10(P(data | genotype)), analogous to the GL tag
        in the VCF spec. The   value ordering is defined by the GL tag
        in the VCF spec.
        """
        self.info = kwargs.get(
            'info', {})
        """
        A map of additional variant call information.
        """
        self.phaseset = kwargs.get(
            'phaseset', None)
        """
        If this field is a string, this variant call's genotype
        ordering implies   the phase of the bases and is consistent
        with any other variant calls on   the same contig which have
        the same phaseset string.    If this field is an array, each
        entry is associated with the corresponding   entry in the
        genotype array. Allele instances that are associated with the
        same phaseset string occur on the same molecule of DNA.    For
        example, if one Call has genotype [0, 1], another is
        associated with   Allele 3, and both have a phaseset of
        ["maternal", "paternal"], then one   DNA molecule carries 0, 3
        and another carries 1, 3.    If the API server supports the
        "classic" mode, this field must not be an   array. If the API
        server supports the "graph" mode and not the "classic" mode,
        this field must be an array.
        """
        self.variantId = kwargs.get(
            'variantId', None)
        """
        The ID of the Variant that this Call belongs to. Must be set
        in any Call   that is not being returned from the server
        already contained within its   Variant.
        """


class CallSet(ProtocolElement):
    """
    A CallSet is a collection of variant calls for a particular
    sample. It belongs to a VariantSet. This is equivalent to one
    column in VCF.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name": "CallSet",
"fields": [{"doc": "", "type": "string", "name": "id"}, {"default":
null, "doc": "", "type": ["null", "string"], "name": "name"}, {"doc":
"", "type": ["null", "string"], "name": "sampleId"}, {"default": [],
"doc": "", "type": {"items": "string", "type": "array"}, "name":
"variantSetIds"}, {"default": null, "doc": "", "type": ["null",
"long"], "name": "created"}, {"default": null, "doc": "", "type":
["null", "long"], "name": "updated"}, {"default": {}, "doc": "",
"type": {"values": {"items": "string", "type": "array"}, "type":
"map"}, "name": "info"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "id",
        "sampleId",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'created', 'id', 'info', 'name', 'sampleId', 'updated',
        'variantSetIds'
    ]

    def __init__(self, **kwargs):
        self.created = kwargs.get(
            'created', None)
        """
        The date this call set was created in milliseconds from the
        epoch.
        """
        self.id = kwargs.get(
            'id', None)
        """
        The call set ID.
        """
        self.info = kwargs.get(
            'info', {})
        """
        A map of additional call set information.
        """
        self.name = kwargs.get(
            'name', None)
        """
        The call set name.
        """
        self.sampleId = kwargs.get(
            'sampleId', None)
        """
        The sample this call set's data was generated from.
        """
        self.updated = kwargs.get(
            'updated', None)
        """
        The time at which this call set was last updated in
        milliseconds from the epoch.
        """
        self.variantSetIds = kwargs.get(
            'variantSetIds', [])
        """
        The IDs of the variant sets this call set has calls in.
        """


class Characterization(ProtocolElement):
    """
    Read characterization data.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"Characterization", "fields": [{"doc": "", "type": "string", "name":
"analysisId"}, {"doc": "", "type": "float", "name": "complexity"},
{"doc": "", "type": "float", "name": "fractionMapped"}, {"doc": "",
"type": "float", "name": "intronicFraction"}, {"doc": "", "type":
"float", "name": "exonicFraction"}, {"doc": "", "type": "float",
"name": "intergenicFraction"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "analysisId",
        "complexity",
        "exonicFraction",
        "fractionMapped",
        "intergenicFraction",
        "intronicFraction",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'analysisId', 'complexity', 'exonicFraction',
        'fractionMapped', 'intergenicFraction', 'intronicFraction'
    ]

    def __init__(self, **kwargs):
        self.analysisId = kwargs.get(
            'analysisId', None)
        """
        The associated RnaQuantification.
        """
        self.complexity = kwargs.get(
            'complexity', None)
        """
        Complexity of the reads
        """
        self.exonicFraction = kwargs.get(
            'exonicFraction', None)
        """
        Fraction of total reads which were mapped to exons.  Values
        range from 0.0 to 1.0.
        """
        self.fractionMapped = kwargs.get(
            'fractionMapped', None)
        """
        Fraction of total reads which were mapped.  Values range from
        0.0 to 1.0.
        """
        self.intergenicFraction = kwargs.get(
            'intergenicFraction', None)
        """
        Fraction of total reads which were mapped to intergenic
        regions.  Values range from 0.0 to 1.0.
        """
        self.intronicFraction = kwargs.get(
            'intronicFraction', None)
        """
        Fraction of total reads which were mapped to introns.  Values
        range from 0.0 to 1.0.
        """


class CigarOperation(object):
    """
    An enum for the different types of CIGAR alignment operations that
    exist. Used wherever CIGAR alignments are used. The different
    enumerated values have the following usage:  * ALIGNMENT_MATCH: An
    alignment match indicates that a sequence can be   aligned to the
    reference without evidence of an INDEL. Unlike the
    SEQUENCE_MATCH and SEQUENCE_MISMATCH operators, the
    ALIGNMENT_MATCH   operator does not indicate whether the reference
    and read sequences are an   exact match. This operator is
    equivalent to SAM's M. * INSERT: The insert operator indicates
    that the read contains evidence of   bases being inserted into the
    reference. This operator is equivalent to   SAM's I. * DELETE: The
    delete operator indicates that the read contains evidence of
    bases being deleted from the reference. This operator is
    equivalent to   SAM's D. * SKIP: The skip operator indicates that
    this read skips a long segment of   the reference, but the bases
    have not been deleted. This operator is   commonly used when
    working with RNA-seq data, where reads may skip long   segments of
    the reference between exons. This operator is equivalent to
    SAM's 'N'. * CLIP_SOFT: The soft clip operator indicates that
    bases at the start/end   of a read have not been considered during
    alignment. This may occur if the   majority of a read maps, except
    for low quality bases at the start/end of   a read. This operator
    is equivalent to SAM's 'S'. Bases that are soft clipped   will
    still be stored in the read. * CLIP_HARD: The hard clip operator
    indicates that bases at the start/end of   a read have been
    omitted from this alignment. This may occur if this linear
    alignment is part of a chimeric alignment, or if the read has been
    trimmed   (e.g., during error correction, or to trim poly-A tails
    for RNA-seq). This   operator is equivalent to SAM's 'H'. * PAD:
    The pad operator indicates that there is padding in an alignment.
    This operator is equivalent to SAM's 'P'. * SEQUENCE_MATCH: This
    operator indicates that this portion of the aligned   sequence
    exactly matches the reference (e.g., all bases are equal to the
    reference bases). This operator is equivalent to SAM's '='. *
    SEQUENCE_MISMATCH: This operator indicates that this portion of
    the   aligned sequence is an alignment match to the reference, but
    a sequence   mismatch (e.g., the bases are not equal to the
    reference). This can   indicate a SNP or a read error. This
    operator is equivalent to SAM's 'X'.
    """
    ALIGNMENT_MATCH = "ALIGNMENT_MATCH"
    INSERT = "INSERT"
    DELETE = "DELETE"
    SKIP = "SKIP"
    CLIP_SOFT = "CLIP_SOFT"
    CLIP_HARD = "CLIP_HARD"
    PAD = "PAD"
    SEQUENCE_MATCH = "SEQUENCE_MATCH"
    SEQUENCE_MISMATCH = "SEQUENCE_MISMATCH"


class CigarUnit(ProtocolElement):
    """
    A structure for an instance of a CIGAR operation.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"CigarUnit", "fields": [{"doc": "", "type": {"symbols":
["ALIGNMENT_MATCH", "INSERT", "DELETE", "SKIP", "CLIP_SOFT",
"CLIP_HARD", "PAD", "SEQUENCE_MATCH", "SEQUENCE_MISMATCH"], "doc": "",
"type": "enum", "name": "CigarOperation"}, "name": "operation"},
{"doc": "", "type": "long", "name": "operationLength"}, {"default":
null, "doc": "", "type": ["null", "string"], "name":
"referenceSequence"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "operation",
        "operationLength",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'operation', 'operationLength', 'referenceSequence'
    ]

    def __init__(self, **kwargs):
        self.operation = kwargs.get(
            'operation', None)
        """
        The operation type.
        """
        self.operationLength = kwargs.get(
            'operationLength', None)
        """
        The number of bases that the operation runs for.
        """
        self.referenceSequence = kwargs.get(
            'referenceSequence', None)
        """
        referenceSequence is only used at mismatches
        (SEQUENCE_MISMATCH)   and deletions (DELETE). Filling this
        field replaces the MD tag.   If the relevant information is
        not available, leave this field as null.
        """


class DataSetResource(ProtocolElement):
    """
    DataSetResource
    """
    _schemaSource = """
{"namespace": "org.ga4gh.beacon", "type": "record", "name":
"DataSetResource", "fields": [{"doc": "", "type": "string", "name":
"id"}, {"doc": "", "type": "string", "name": "reference"}, {"default":
null, "doc": "", "type": ["null", "string"], "name": "description"},
{"default": null, "doc": "", "type": ["null", {"doc": "", "type":
"record", "name": "DataSizeResource", "fields": [{"doc": "", "type":
"int", "name": "variants"}, {"doc": "", "type": "int", "name":
"samples"}]}], "name": "size"}, {"default": [], "doc": "", "type":
{"items": {"doc": "", "type": "record", "name": "DataUseResource",
"fields": [{"doc": "", "type": "string", "name": "category"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"description"}, {"default": [], "doc": "", "type": {"items": {"doc":
"", "type": "record", "name": "DataUseRequirementResource", "fields":
[{"doc": "", "type": "string", "name": "name"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "description"}]},
"type": "array"}, "name": "requirements"}]}, "type": "array"}, "name":
"data_use"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "id",
        "reference",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'data_use': DataUseResource,
            'size': DataSizeResource,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'data_use': DataUseResource,
            'size': DataSizeResource,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'data_use', 'description', 'id', 'reference', 'size'
    ]

    def __init__(self, **kwargs):
        self.data_use = kwargs.get(
            'data_use', [])
        """
        Data use limitations, specified as a set of DataUseResource.
        """
        self.description = kwargs.get(
            'description', None)
        """
        Dataset description
        """
        self.id = kwargs.get(
            'id', None)
        """
        Dataset name
        """
        self.reference = kwargs.get(
            'reference', None)
        """
        Reference genome
        """
        self.size = kwargs.get(
            'size', None)
        """
        Dimensions of the data set. Should be provided if the beacon
        reports allele frequencies.
        """


class DataSizeResource(ProtocolElement):
    """
    DataSetSizeResource
    """
    _schemaSource = """
{"namespace": "org.ga4gh.beacon", "type": "record", "name":
"DataSizeResource", "fields": [{"doc": "", "type": "int", "name":
"variants"}, {"doc": "", "type": "int", "name": "samples"}], "doc":
""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "samples",
        "variants",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'samples', 'variants'
    ]

    def __init__(self, **kwargs):
        self.samples = kwargs.get(
            'samples', None)
        """
        Total number of samples in the data set
        """
        self.variants = kwargs.get(
            'variants', None)
        """
        Total number of variant positions in the data set
        """


class DataUseRequirementResource(ProtocolElement):
    """
    DataUseRequirementResource
    """
    _schemaSource = """
{"namespace": "org.ga4gh.beacon", "type": "record", "name":
"DataUseRequirementResource", "fields": [{"doc": "", "type": "string",
"name": "name"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "description"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "name",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'description', 'name'
    ]

    def __init__(self, **kwargs):
        self.description = kwargs.get(
            'description', None)
        """
        Description of Data Use requirement.
        """
        self.name = kwargs.get(
            'name', None)
        """
        Data Use requirement
        """


class DataUseResource(ProtocolElement):
    """
    DataUseResource
    """
    _schemaSource = """
{"namespace": "org.ga4gh.beacon", "type": "record", "name":
"DataUseResource", "fields": [{"doc": "", "type": "string", "name":
"category"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "description"}, {"default": [], "doc": "", "type": {"items":
{"doc": "", "type": "record", "name": "DataUseRequirementResource",
"fields": [{"doc": "", "type": "string", "name": "name"}, {"default":
null, "doc": "", "type": ["null", "string"], "name": "description"}]},
"type": "array"}, "name": "requirements"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "category",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'requirements': DataUseRequirementResource,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'requirements': DataUseRequirementResource,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'category', 'description', 'requirements'
    ]

    def __init__(self, **kwargs):
        self.category = kwargs.get(
            'category', None)
        """
        Data Use category.
        """
        self.description = kwargs.get(
            'description', None)
        """
        Description of Data Use category.
        """
        self.requirements = kwargs.get(
            'requirements', [])
        """
        Data Use requirements.
        """


class Dataset(ProtocolElement):
    """
    No documentation
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name": "Dataset",
"fields": [{"doc": "", "type": "string", "name": "id"}, {"default":
null, "doc": "", "type": ["null", "string"], "name": "description"}]}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "id",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'description', 'id'
    ]

    def __init__(self, **kwargs):
        self.description = kwargs.get(
            'description', None)
        """
        The dataset description.
        """
        self.id = kwargs.get(
            'id', None)
        """
        The dataset ID.
        """


class ErrorResource(ProtocolElement):
    """
    ErrorResource
    """
    _schemaSource = """
{"namespace": "org.ga4gh.beacon", "type": "record", "name":
"ErrorResource", "fields": [{"doc": "", "type": "string", "name":
"name"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "description"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "name",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'description', 'name'
    ]

    def __init__(self, **kwargs):
        self.description = kwargs.get(
            'description', None)
        """
        Error message.
        """
        self.name = kwargs.get(
            'name', None)
        """
        Error name/code, e.g. "bad_request" or "unauthorized".
        """


class Experiment(ProtocolElement):
    """
    An experimental preparation of a Sample.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"Experiment", "fields": [{"doc": "", "type": "string", "name": "id"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"name"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "description"}, {"doc": "", "type": "string", "name":
"recordCreateTime"}, {"doc": "", "type": "string", "name":
"recordUpdateTime"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "runTime"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "molecule"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "strategy"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "selection"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"library"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "libraryLayout"}, {"doc": "", "type": ["null", "string"],
"name": "instrumentModel"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "instrumentDataFile"}, {"doc": "", "type":
["null", "string"], "name": "sequencingCenter"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "platformUnit"},
{"default": {}, "doc": "", "type": {"values": {"items": "string",
"type": "array"}, "type": "map"}, "name": "info"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "id",
        "instrumentModel",
        "recordCreateTime",
        "recordUpdateTime",
        "sequencingCenter",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'description', 'id', 'info', 'instrumentDataFile',
        'instrumentModel', 'library', 'libraryLayout', 'molecule',
        'name', 'platformUnit', 'recordCreateTime',
        'recordUpdateTime', 'runTime', 'selection',
        'sequencingCenter', 'strategy'
    ]

    def __init__(self, **kwargs):
        self.description = kwargs.get(
            'description', None)
        """
        A description of the experiment.
        """
        self.id = kwargs.get(
            'id', None)
        """
        The experiment UUID. This is globally unique.
        """
        self.info = kwargs.get(
            'info', {})
        """
        A map of additional experiment information.
        """
        self.instrumentDataFile = kwargs.get(
            'instrumentDataFile', None)
        """
        The data file generated by the instrument.   TODO: This isn't
        actually a file is it?   Should this be instrumentData
        instead?
        """
        self.instrumentModel = kwargs.get(
            'instrumentModel', None)
        """
        The instrument model used as part of this experiment.     This
        maps to sequencing technology in BAM.
        """
        self.library = kwargs.get(
            'library', None)
        """
        The name of the library used as part of this experiment.
        """
        self.libraryLayout = kwargs.get(
            'libraryLayout', None)
        """
        The configuration of sequenced reads. (e.g. Single or Paired)
        """
        self.molecule = kwargs.get(
            'molecule', None)
        """
        The molecule examined in this experiment. (e.g. genomics DNA,
        total RNA)
        """
        self.name = kwargs.get(
            'name', None)
        """
        The name of the experiment.
        """
        self.platformUnit = kwargs.get(
            'platformUnit', None)
        """
        The platform unit used as part of this experiment. This is a
        flowcell-barcode   or slide unique identifier.
        """
        self.recordCreateTime = kwargs.get(
            'recordCreateTime', None)
        """
        The time at which this record was created.    Format: ISO
        8601, YYYY-MM-DDTHH:MM:SS.SSS (e.g. 2015-02-10T00:03:42.123Z)
        """
        self.recordUpdateTime = kwargs.get(
            'recordUpdateTime', None)
        """
        The time at which this record was last updated.   Format: ISO
        8601, YYYY-MM-DDTHH:MM:SS.SSS (e.g. 2015-02-10T00:03:42.123Z)
        """
        self.runTime = kwargs.get(
            'runTime', None)
        """
        The time at which this experiment was performed.   Granularity
        here is variabel (e.g. date only).   Format: ISO 8601, YYYY-
        MM-DDTHH:MM:SS (e.g. 2015-02-10T00:03:42)
        """
        self.selection = kwargs.get(
            'selection', None)
        """
        The method used to enrich the target. (e.g.
        immunoprecipitation, size   fractionation, MNase digestion)
        """
        self.sequencingCenter = kwargs.get(
            'sequencingCenter', None)
        """
        The sequencing center used as part of this experiment.
        """
        self.strategy = kwargs.get(
            'strategy', None)
        """
        The experiment technique or strategy applied to the sample.
        (e.g. whole genome sequencing, RNA-seq, RIP-seq)
        """


class ExpressionLevel(ProtocolElement):
    """
    The actual FPKM data for each feature.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"ExpressionLevel", "fields": [{"doc": "", "type": "string", "name":
"id"}, {"doc": "", "type": "string", "name": "featureGroupId"},
{"doc": "", "type": "string", "name": "annotationId"}, {"doc": "",
"type": "float", "name": "rawReadCount"}, {"default": null, "doc": "",
"type": ["null", "float"], "name": "expression"}, {"default": null,
"doc": "", "type": ["null", "boolean"], "name": "isNormalized"},
{"default": null, "doc": "", "type": ["null", {"symbols": ["FPKM",
"RPM"], "doc": "", "type": "enum", "name": "ExpressionUnits"}],
"name": "units"}, {"default": null, "doc": "", "type": ["null",
"float"], "name": "score"}, {"default": [], "doc": "", "type":
{"items": "float", "type": "array"}, "name": "confInterval"}], "doc":
""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "annotationId",
        "featureGroupId",
        "id",
        "rawReadCount",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'annotationId', 'confInterval', 'expression',
        'featureGroupId', 'id', 'isNormalized', 'rawReadCount',
        'score', 'units'
    ]

    def __init__(self, **kwargs):
        self.annotationId = kwargs.get(
            'annotationId', None)
        """
        The associated annotation.
        """
        self.confInterval = kwargs.get(
            'confInterval', [])
        """
        Confidence interval on the expression value.  Expressed as a
        sorted array   from low to high.
        """
        self.expression = kwargs.get(
            'expression', None)
        """
        Numerical expression value.
        """
        self.featureGroupId = kwargs.get(
            'featureGroupId', None)
        """
        The associated FeatureGoup.
        """
        self.id = kwargs.get(
            'id', None)
        """
        Feature ID
        """
        self.isNormalized = kwargs.get(
            'isNormalized', None)
        """
        True if the expression value is a normalized value.
        """
        self.rawReadCount = kwargs.get(
            'rawReadCount', None)
        """
        The number of reads mapped to this feature.
        """
        self.score = kwargs.get(
            'score', None)
        """
        Weighted score for the expression value.
        """
        self.units = kwargs.get(
            'units', None)
        """
        The units of the expression value if one is given.
        """


class ExpressionUnits(object):
    """
    Units for expression level
    """
    FPKM = "FPKM"
    RPM = "RPM"


class ExternalIdentifier(ProtocolElement):
    """
    Identifier from a public database
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"ExternalIdentifier", "fields": [{"doc": "", "type": "string", "name":
"database"}, {"doc": "", "type": "string", "name": "identifier"},
{"doc": "", "type": "string", "name": "version"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "database",
        "identifier",
        "version",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'database', 'identifier', 'version'
    ]

    def __init__(self, **kwargs):
        self.database = kwargs.get(
            'database', None)
        """
        The source of the identifier.   (e.g. Ensembl)
        """
        self.identifier = kwargs.get(
            'identifier', None)
        """
        The ID defined by the external database.   (e.g.
        ENST00000000000)
        """
        self.version = kwargs.get(
            'version', None)
        """
        The version of the object or the database   (e.g. 78)
        """


class ExtractSubgraphJoinsRequest(ProtocolElement):
    """
    This request maps to the body of POST /subgraph/joins as JSON.
    Specifies aPosition and a radius (in bases), and requests all
    Joins reachable within that number of bases from that position.
    Starting at the specified Position, and with a 0 radius denoting
    only that Position, walk outwards this many bases along all
    possible paths, traversing Joins only if necessary. All Joins
    traversed during this walk should be returned.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"ExtractSubgraphJoinsRequest", "fields": [{"default": null, "doc": "",
"type": ["null", "string"], "name": "referenceSetId"}, {"default":
null, "doc": "", "type": ["null", "string"], "name": "variantSetId"},
{"doc": "", "type": {"namespace": "org.ga4gh.models", "type":
"record", "name": "Position", "fields": [{"default": null, "doc": "",
"type": ["null", "string"], "name": "sequenceId"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "referenceName"},
{"doc": "", "type": "long", "name": "position"}], "doc": ""}, "name":
"position"}, {"doc": "", "type": "long", "name": "radius"},
{"default": null, "doc": "", "type": ["null", "int"], "name":
"pageSize"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "pageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "position",
        "radius",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'position': Position,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'position': Position,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'pageSize', 'pageToken', 'position', 'radius',
        'referenceSetId', 'variantSetId'
    ]

    def __init__(self, **kwargs):
        self.pageSize = kwargs.get(
            'pageSize', None)
        """
        Specifies the maximum number of results to return in a single
        page.   If unspecified, a system default will be used.
        """
        self.pageToken = kwargs.get(
            'pageToken', None)
        """
        The continuation token, which is used to page through large
        result sets.   To get the next page of results, set this
        parameter to the value of   nextPageToken from the previous
        response.
        """
        self.position = kwargs.get(
            'position', None)
        """
        Base around which the subgraph is to be extracted.
        """
        self.radius = kwargs.get(
            'radius', None)
        """
        Distance from the position to walk along all possible paths,
        when looking   for Joins to include in the returned subgraph.
        """
        self.referenceSetId = kwargs.get(
            'referenceSetId', None)
        """
        If not null, return only Joins which belong to this
        reference set, or any included ReferenceSets.    If null,
        variantSetId must not be null.
        """
        self.variantSetId = kwargs.get(
            'variantSetId', None)
        """
        If not null, return only Joins which belong to this variant
        set.    If null, referenceSetId must not be null.
        """


class ExtractSubgraphJoinsResponse(ProtocolElement):
    """
    This is the response from POST /subgraph/joins expressed as JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"ExtractSubgraphJoinsResponse", "fields": [{"default": [], "doc": "",
"type": {"items": {"namespace": "org.ga4gh.models", "type": "record",
"name": "Join", "fields": [{"doc": "", "type": {"doc": "", "type":
"record", "name": "Side", "fields": [{"doc": "", "type": {"doc": "",
"type": "record", "name": "Position", "fields": [{"default": null,
"doc": "", "type": ["null", "string"], "name": "sequenceId"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"referenceName"}, {"doc": "", "type": "long", "name": "position"}]},
"name": "base"}, {"doc": "", "type": {"symbols": ["NEG_STRAND",
"POS_STRAND"], "doc": "", "type": "enum", "name": "Strand"}, "name":
"strand"}]}, "name": "side1"}, {"doc": "", "type": "Side", "name":
"side2"}], "doc": ""}, "type": "array"}, "name": "joins"}, {"default":
null, "doc": "", "type": ["null", "string"], "name":
"nextPageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'joins': Join,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'joins': Join,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'joins', 'nextPageToken'
    ]

    def __init__(self, **kwargs):
        self.joins = kwargs.get(
            'joins', [])
        """
        The list of Joins in the subgraph. Joins are returned in
        arbitrary   order, but each Join will be returned only once.
        """
        self.nextPageToken = kwargs.get(
            'nextPageToken', None)
        """
        The continuation token, which is used to page through large
        result sets.   Provide this value in a subsequent request to
        return the next page of   results. This field will be empty if
        there aren't any additional results.
        """


class ExtractSubgraphSegmentsRequest(ProtocolElement):
    """
    This request maps to the body of POST /subgraph/sequences as JSON.
    Specifies aPosition and a radius (in bases), and requests all
    Segments reachable within that number of bases from that position.
    Starting at the specified Position, and with a 0 radius denoting
    only that Position, walk outwards this many bases along all
    possible paths, traversing Joins only if necessary. All Segments
    covering all bases visited during this walk should be returned.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"ExtractSubgraphSegmentsRequest", "fields": [{"default": null, "doc":
"", "type": ["null", "string"], "name": "referenceSetId"}, {"default":
null, "doc": "", "type": ["null", "string"], "name": "variantSetId"},
{"doc": "", "type": {"namespace": "org.ga4gh.models", "type":
"record", "name": "Position", "fields": [{"default": null, "doc": "",
"type": ["null", "string"], "name": "sequenceId"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "referenceName"},
{"doc": "", "type": "long", "name": "position"}], "doc": ""}, "name":
"position"}, {"doc": "", "type": "long", "name": "radius"},
{"default": null, "doc": "", "type": ["null", "int"], "name":
"pageSize"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "pageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "position",
        "radius",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'position': Position,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'position': Position,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'pageSize', 'pageToken', 'position', 'radius',
        'referenceSetId', 'variantSetId'
    ]

    def __init__(self, **kwargs):
        self.pageSize = kwargs.get(
            'pageSize', None)
        """
        Specifies the maximum number of results to return in a single
        page.   If unspecified, a system default will be used.
        """
        self.pageToken = kwargs.get(
            'pageToken', None)
        """
        The continuation token, which is used to page through large
        result sets.   To get the next page of results, set this
        parameter to the value of   nextPageToken from the previous
        response.
        """
        self.position = kwargs.get(
            'position', None)
        """
        Base around which the subgraph is to be extracted.
        """
        self.radius = kwargs.get(
            'radius', None)
        """
        Distance from the position to walk along all possible paths,
        when looking   for bases to include in the returned subgraph.
        """
        self.referenceSetId = kwargs.get(
            'referenceSetId', None)
        """
        If not null, return only Segments of Sequences which belong to
        this   reference set, or any included ReferenceSets.    If
        null, variantSetId must not be null.
        """
        self.variantSetId = kwargs.get(
            'variantSetId', None)
        """
        If not null, return only Segments of Sequences which belong to
        this   variant set.    If null, referenceSetId must not be
        null.
        """


class ExtractSubgraphSegmentsResponse(ProtocolElement):
    """
    This is the response from POST /subgraph/segments expressed as
    JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"ExtractSubgraphSegmentsResponse", "fields": [{"default": [], "doc":
"", "type": {"items": {"namespace": "org.ga4gh.models", "type":
"record", "name": "Segment", "fields": [{"doc": "", "type": {"doc":
"", "type": "record", "name": "Side", "fields": [{"doc": "", "type":
{"doc": "", "type": "record", "name": "Position", "fields":
[{"default": null, "doc": "", "type": ["null", "string"], "name":
"sequenceId"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "referenceName"}, {"doc": "", "type": "long",
"name": "position"}]}, "name": "base"}, {"doc": "", "type":
{"symbols": ["NEG_STRAND", "POS_STRAND"], "doc": "", "type": "enum",
"name": "Strand"}, "name": "strand"}]}, "name": "start"}, {"doc": "",
"type": "long", "name": "length"}], "doc": ""}, "type": "array"},
"name": "segments"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "nextPageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'segments': Segment,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'segments': Segment,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'nextPageToken', 'segments'
    ]

    def __init__(self, **kwargs):
        self.nextPageToken = kwargs.get(
            'nextPageToken', None)
        """
        The continuation token, which is used to page through large
        result sets.   Provide this value in a subsequent request to
        return the next page of   results. This field will be empty if
        there aren't any additional results.
        """
        self.segments = kwargs.get(
            'segments', [])
        """
        The list of Segments in the subgraph. Segments are returned in
        arbitrary   order, and multiple Segments may abut, but each is
        returned only once and no   two may overlap.
        """


class Feature(ProtocolElement):
    """
    Node in the annotation graph that annotates a contiguous region of
    a   sequence.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name": "Feature",
"fields": [{"doc": "", "type": "string", "name": "id"}, {"doc": "",
"type": {"items": "string", "type": "array"}, "name": "parentIds"},
{"doc": "", "type": "string", "name": "featureSetId"}, {"default":
null, "doc": "", "type": ["null", "string"], "name": "referenceName"},
{"default": null, "doc": "", "type": ["null", "long"], "name":
"start"}, {"default": null, "doc": "", "type": ["null", "long"],
"name": "end"}, {"doc": "", "type": {"doc": "", "type": "record",
"name": "OntologyTerm", "fields": [{"doc": "", "type": "string",
"name": "ontologySource"}, {"doc": "", "type": "string", "name":
"id"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "name"}]}, "name": "featureType"}, {"doc": "", "type": {"doc":
"", "type": "record", "name": "Attributes", "fields": [{"default": {},
"type": {"values": {"items": ["string", {"doc": "", "type": "record",
"name": "ExternalIdentifier", "fields": [{"doc": "", "type": "string",
"name": "database"}, {"doc": "", "type": "string", "name":
"identifier"}, {"doc": "", "type": "string", "name": "version"}]},
"OntologyTerm"], "type": "array"}, "type": "map"}, "name": "vals"}]},
"name": "attributes"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "attributes",
        "featureSetId",
        "featureType",
        "id",
        "parentIds",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'attributes': Attributes,
            'featureType': OntologyTerm,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'attributes': Attributes,
            'featureType': OntologyTerm,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'attributes', 'end', 'featureSetId', 'featureType', 'id',
        'parentIds', 'referenceName', 'start'
    ]

    def __init__(self, **kwargs):
        self.attributes = kwargs.get(
            'attributes', None)
        """
        Name/value attributes of the annotation.  Attribute names
        follow the GFF3     naming convention of reserved names
        starting with an upper cases     character, and user-define
        names start with lower-case.  Most GFF3     pre-defined
        attributes apply, the exceptions are ID and Parent, which are
        defined as fields. Additional, the following attributes are
        added:     * Score - the GFF3 score column     * Phase - the
        GFF3 phase column for CDS features.
        """
        self.end = kwargs.get(
            'end', None)
        """
        The end position (exclusive), resulting in [start, end)
        closed-open interval.     This is typically calculated by
        start + referenceBases.length.      If the API server supports
        the "classic" mode, this field must not be null.
        """
        self.featureSetId = kwargs.get(
            'featureSetId', None)
        """
        Identifier for the containing feature set.
        """
        self.featureType = kwargs.get(
            'featureType', None)
        """
        Feature that is annotated by this region.  Normally, this will
        be a term in     the Sequence Ontology.
        """
        self.id = kwargs.get(
            'id', None)
        """
        Id of this annotation node.
        """
        self.parentIds = kwargs.get(
            'parentIds', None)
        """
        Ids of the parents of this annotation node.
        """
        self.referenceName = kwargs.get(
            'referenceName', None)
        """
        The reference on which this feature occurs.     (e.g. chr20 or
        X)      If the API server supports the "classic" mode, this
        field must not be null.
        """
        self.start = kwargs.get(
            'start', None)
        """
        The start position at which this feature occurs (0-based).
        This corresponds to the first base of the string of reference
        bases.     Genomic positions are non-negative integers less
        than reference length.     Features spanning the join of
        circular genomes are represented as     two features one on
        each side of the join (position 0).      If the API server
        supports the "classic" mode, this field must not be null.
        """


class FeatureGroup(ProtocolElement):
    """
    Identifying information for annotated features.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"FeatureGroup", "fields": [{"doc": "", "type": "string", "name":
"id"}, {"doc": "", "type": "string", "name": "analysisId"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"name"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "description"}, {"default": null, "doc": "", "type": ["null",
"long"], "name": "created"}, {"default": null, "doc": "", "type":
["null", "long"], "name": "updated"}, {"default": {}, "doc": "",
"type": {"values": {"items": "string", "type": "array"}, "type":
"map"}, "name": "info"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "analysisId",
        "id",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'analysisId', 'created', 'description', 'id', 'info', 'name',
        'updated'
    ]

    def __init__(self, **kwargs):
        self.analysisId = kwargs.get(
            'analysisId', None)
        """
        The associated RnaQuantification.
        """
        self.created = kwargs.get(
            'created', None)
        """
        The time at which this feature group was created in
        milliseconds from the epoch.
        """
        self.description = kwargs.get(
            'description', None)
        """
        Description
        """
        self.id = kwargs.get(
            'id', None)
        """
        Feature group ID
        """
        self.info = kwargs.get(
            'info', {})
        """
        A map of additional feature group information.
        """
        self.name = kwargs.get(
            'name', None)
        """
        Name
        """
        self.updated = kwargs.get(
            'updated', None)
        """
        The time at which this feature group was last updated in
        milliseconds   from the epoch.
        """


class FeatureSet(ProtocolElement):
    """
    No documentation
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"FeatureSet", "fields": [{"doc": "", "type": "string", "name": "id"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"datasetId"}, {"doc": "", "type": ["null", "string"], "name":
"referenceSetId"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "name"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "sourceURI"}, {"doc": "", "type": {"doc":
"", "type": "record", "name": "Attributes", "fields": [{"default": {},
"type": {"values": {"items": ["string", {"doc": "", "type": "record",
"name": "ExternalIdentifier", "fields": [{"doc": "", "type": "string",
"name": "database"}, {"doc": "", "type": "string", "name":
"identifier"}, {"doc": "", "type": "string", "name": "version"}]},
{"doc": "", "type": "record", "name": "OntologyTerm", "fields":
[{"doc": "", "type": "string", "name": "ontologySource"}, {"doc": "",
"type": "string", "name": "id"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "name"}]}], "type": "array"}, "type":
"map"}, "name": "vals"}]}, "name": "attributes"}]}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "attributes",
        "id",
        "referenceSetId",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'attributes': Attributes,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'attributes': Attributes,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'attributes', 'datasetId', 'id', 'name', 'referenceSetId',
        'sourceURI'
    ]

    def __init__(self, **kwargs):
        self.attributes = kwargs.get(
            'attributes', None)
        """
        Set of additional attributes
        """
        self.datasetId = kwargs.get(
            'datasetId', None)
        """
        The ID of the dataset this annotation set belongs to.
        """
        self.id = kwargs.get(
            'id', None)
        """
        The ID of this annotation set.
        """
        self.name = kwargs.get(
            'name', None)
        """
        The display name for this annotation set.
        """
        self.referenceSetId = kwargs.get(
            'referenceSetId', None)
        """
        The ID of the reference set which defines the coordinate-space
        for this     set of annotations.
        """
        self.sourceURI = kwargs.get(
            'sourceURI', None)
        """
        The source URI describing the file from which this annotation
        set was     generated, if any.
        """


class Fragment(ProtocolElement):
    """
    A fragment represents a contiguous stretch of a DNA or RNA
    molecule. Reads can be associated with a fragment to specify they
    derive from the same molecule.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"Fragment", "fields": [{"doc": "", "type": "string", "name": "id"}],
"doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "id",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'id'
    ]

    def __init__(self, **kwargs):
        self.id = kwargs.get(
            'id', None)
        """
        The fragment ID.
        """


class GAException(ProtocolElement):
    """
    A general exception type.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "error", "name":
"GAException", "fields": [{"doc": "", "type": "string", "name":
"message"}, {"default": -1, "doc": "", "type": "int", "name":
"errorCode"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "message",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'errorCode', 'message'
    ]

    def __init__(self, **kwargs):
        self.errorCode = kwargs.get(
            'errorCode', -1)
        """
        The numerical error code
        """
        self.message = kwargs.get(
            'message', None)
        """
        The error message
        """


class GetSequenceBasesResponse(ProtocolElement):
    """
    The response from GET /sequences/{id}/bases expressed as JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"GetSequenceBasesResponse", "fields": [{"default": 0, "doc": "",
"type": "long", "name": "offset"}, {"doc": "", "type": "string",
"name": "sequence"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "sequence",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'offset', 'sequence'
    ]

    def __init__(self, **kwargs):
        self.offset = kwargs.get(
            'offset', 0)
        """
        The offset position (0-based) of the returned string in the
        sequence. This   value should match the start request
        parameter, or be 0.
        """
        self.sequence = kwargs.get(
            'sequence', None)
        """
        A substring of the sequence requested. Bases are represented
        as IUPAC-IUB   codes; this string matches the regexp
        [ACGTMRWSYKVHDBN]*.
        """


class GraphAlignment(ProtocolElement):
    """
    A string-to-reference-graph alignment can be represented by one
    CIGAR string and one Path through multiple References, against
    which the CIGAR string is interpreted.  Note that Paths in
    GraphAlignments are restricted to visiting References and
    following reference adjacencies. If a read needs to be aligned to
    sequences that are not present in a ReferenceSet, it needs to be
    aligned to a new ReferenceSet with those sequences. If a read
    needs to follow adjacencies that are not present in the
    ReferenceSet it's being aligned to, it should be represented as a
    "chimeric" alignment, and should use multiple ReadAlignments and
    the supplementaryAlignment flag instead of a single
    GraphAlignment.  Some especially large deletions could be
    represented just as well as a large deletion in the CIGAR string,
    or as a chimeric alignment.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"GraphAlignment", "fields": [{"doc": "", "type": {"doc": "", "type":
"record", "name": "Path", "fields": [{"default": [], "doc": "",
"type": {"items": {"doc": "", "type": "record", "name": "Segment",
"fields": [{"doc": "", "type": {"doc": "", "type": "record", "name":
"Side", "fields": [{"doc": "", "type": {"doc": "", "type": "record",
"name": "Position", "fields": [{"default": null, "doc": "", "type":
["null", "string"], "name": "sequenceId"}, {"default": null, "doc":
"", "type": ["null", "string"], "name": "referenceName"}, {"doc": "",
"type": "long", "name": "position"}]}, "name": "base"}, {"doc": "",
"type": {"symbols": ["NEG_STRAND", "POS_STRAND"], "doc": "", "type":
"enum", "name": "Strand"}, "name": "strand"}]}, "name": "start"},
{"doc": "", "type": "long", "name": "length"}]}, "type": "array"},
"name": "segments"}]}, "name": "path"}, {"default": null, "doc": "",
"type": ["null", "int"], "name": "mappingQuality"}, {"default": [],
"doc": "", "type": {"items": {"doc": "", "type": "record", "name":
"CigarUnit", "fields": [{"doc": "", "type": {"symbols":
["ALIGNMENT_MATCH", "INSERT", "DELETE", "SKIP", "CLIP_SOFT",
"CLIP_HARD", "PAD", "SEQUENCE_MATCH", "SEQUENCE_MISMATCH"], "doc": "",
"type": "enum", "name": "CigarOperation"}, "name": "operation"},
{"doc": "", "type": "long", "name": "operationLength"}, {"default":
null, "doc": "", "type": ["null", "string"], "name":
"referenceSequence"}]}, "type": "array"}, "name": "cigar"}], "doc":
""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "path",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'cigar': CigarUnit,
            'path': Path,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'cigar': CigarUnit,
            'path': Path,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'cigar', 'mappingQuality', 'path'
    ]

    def __init__(self, **kwargs):
        self.cigar = kwargs.get(
            'cigar', [])
        """
        Represents the local alignment of this sequence (alignment
        matches, indels,   etc) versus the Path.
        """
        self.mappingQuality = kwargs.get(
            'mappingQuality', None)
        """
        The mapping quality of this alignment. Represents how likely
        the read maps to this position as opposed to other locations.
        """
        self.path = kwargs.get(
            'path', None)
        """
        The Path against which the read is aligned
        """


class Individual(ProtocolElement):
    """
    An individual (or subject) typically corresponds to an individual
    human or other organism.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"Individual", "fields": [{"doc": "", "type": "string", "name": "id"},
{"default": [], "doc": "", "type": {"items": "string", "type":
"array"}, "name": "groupIds"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "name"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "description"}, {"doc": "",
"type": "string", "name": "recordCreateTime"}, {"doc": "", "type":
"string", "name": "recordUpdateTime"}, {"default": null, "doc": "",
"type": ["null", {"doc": "", "type": "record", "name": "OntologyTerm",
"fields": [{"default": null, "doc": "", "type": ["null", "string"],
"name": "ontologySourceName"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "ontologySourceID"}, {"default": null,
"doc": "", "type": ["null", "string"], "name":
"ontologySourceVersion"}]}], "name": "species"}, {"default": null,
"doc": "", "type": ["null", "OntologyTerm"], "name": "sex"},
{"default": null, "doc": "", "type": ["null", "OntologyTerm"], "name":
"developmentalStage"}, {"default": null, "doc": "", "type": ["null",
"long"], "name": "dateOfBirth"}, {"default": [], "doc": "", "type":
{"items": "OntologyTerm", "type": "array"}, "name": "diseases"},
{"default": [], "doc": "", "type": {"items": "OntologyTerm", "type":
"array"}, "name": "phenotypes"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "stagingSystem"}, {"default": null, "doc":
"", "type": ["null", "string"], "name": "clinicalTreatment"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"strain"}, {"default": {}, "doc": "", "type": {"values": {"items":
"string", "type": "array"}, "type": "map"}, "name": "info"}], "doc":
""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "id",
        "recordCreateTime",
        "recordUpdateTime",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'developmentalStage': OntologyTerm,
            'diseases': OntologyTerm,
            'phenotypes': OntologyTerm,
            'sex': OntologyTerm,
            'species': OntologyTerm,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'developmentalStage': OntologyTerm,
            'diseases': OntologyTerm,
            'phenotypes': OntologyTerm,
            'sex': OntologyTerm,
            'species': OntologyTerm,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'clinicalTreatment', 'dateOfBirth', 'description',
        'developmentalStage', 'diseases', 'groupIds', 'id', 'info',
        'name', 'phenotypes', 'recordCreateTime', 'recordUpdateTime',
        'sex', 'species', 'stagingSystem', 'strain'
    ]

    def __init__(self, **kwargs):
        self.clinicalTreatment = kwargs.get(
            'clinicalTreatment', None)
        """
        A description of the clinical treatment used for this
        individual.
        """
        self.dateOfBirth = kwargs.get(
            'dateOfBirth', None)
        """
        The date of birth of this individual in milliseconds from the
        epoch.   This field may be approximate.
        """
        self.description = kwargs.get(
            'description', None)
        """
        A description of the individual.
        """
        self.developmentalStage = kwargs.get(
            'developmentalStage', None)
        """
        The developmental stage of this individual. Using Uberon is
        recommended.   TODO: Add link to uberon
        """
        self.diseases = kwargs.get(
            'diseases', [])
        """
        Diseases with which the individual has been diagnosed.   TODO:
        Is this the right representation?
        """
        self.groupIds = kwargs.get(
            'groupIds', [])
        """
        The IDs of the individual groups this individual belongs to.
        """
        self.id = kwargs.get(
            'id', None)
        """
        The individual UUID. This is globally unique.
        """
        self.info = kwargs.get(
            'info', {})
        """
        A map of additional individual information.
        """
        self.name = kwargs.get(
            'name', None)
        """
        The name of the individual.
        """
        self.phenotypes = kwargs.get(
            'phenotypes', [])
        """
        Phenotypes for this individual.   TODO: Is this the right
        representation?
        """
        self.recordCreateTime = kwargs.get(
            'recordCreateTime', None)
        """
        The time at which this record was created.    Format: ISO
        8601, YYYY-MM-DDTHH:MM:SS.SSS (e.g. 2015-02-10T00:03:42.123Z)
        TODO: The format definition is temporary and will be updated
        to    the upcoming AVRO time format (timestamp-millis) when
        this is supported.
        """
        self.recordUpdateTime = kwargs.get(
            'recordUpdateTime', None)
        """
        The time at which this record was last updated.   Format: ISO
        8601, YYYY-MM-DDTHH:MM:SS.SSS (e.g. 2015-02-10T00:03:42.123Z)
        """
        self.sex = kwargs.get(
            'sex', None)
        """
        The genetic sex of this individual. Use null when unknown.
        """
        self.species = kwargs.get(
            'species', None)
        """
        The species of this individual. Using   [NCBI
        taxonomy](http://www.ncbi.nlm.nih.gov/taxonomy) is
        recommended.   For a representation of an NCBI Taxon ID as an
        OntologyTerm, see   [NCBITaxon Ontology](http://www.obofoundry
        .org/wiki/index.php/NCBITaxon:Main_Page).   For example, 'Homo
        sapiens' has the ID 9606. The NCBITaxon ontology ID for this
        is   NCBITaxon:9606, which has the URI
        http://purl.obolibrary.org/obo/NCBITaxon_9606
        """
        self.stagingSystem = kwargs.get(
            'stagingSystem', None)
        """
        Disease area specific classification (e.g. classification of
        cancer samples   such as Dukes)
        """
        self.strain = kwargs.get(
            'strain', None)
        """
        The strain of this individual, for non-humans.
        """


class IndividualGroup(ProtocolElement):
    """
    Represents a group of individuals. (e.g. a trio)
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"IndividualGroup", "fields": [{"doc": "", "type": "string", "name":
"id"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "name"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "description"}, {"doc": "", "type": "string",
"name": "recordCreateTime"}, {"doc": "", "type": "string", "name":
"recordUpdateTime"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "type"}, {"default": {}, "doc": "", "type":
{"values": {"items": "string", "type": "array"}, "type": "map"},
"name": "info"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "id",
        "recordCreateTime",
        "recordUpdateTime",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'description', 'id', 'info', 'name', 'recordCreateTime',
        'recordUpdateTime', 'type'
    ]

    def __init__(self, **kwargs):
        self.description = kwargs.get(
            'description', None)
        """
        A description of the individual group.
        """
        self.id = kwargs.get(
            'id', None)
        """
        The individual group UUID. This is globally unique.
        """
        self.info = kwargs.get(
            'info', {})
        """
        A map of additional individual group information.
        """
        self.name = kwargs.get(
            'name', None)
        """
        The name of the individual group.
        """
        self.recordCreateTime = kwargs.get(
            'recordCreateTime', None)
        """
        The time at which this record was created.    Format: ISO
        8601, YYYY-MM-DDTHH:MM:SS.SSS (e.g. 2015-02-10T00:03:42.123Z)
        """
        self.recordUpdateTime = kwargs.get(
            'recordUpdateTime', None)
        """
        The time at which this record was last updated.   Format: ISO
        8601, YYYY-MM-DDTHH:MM:SS.SSS (e.g. 2015-02-10T00:03:42.123Z)
        """
        self.type = kwargs.get(
            'type', None)
        """
        The type of individual group.
        """


class Join(ProtocolElement):
    """
    A Join is simply a pair of Side objects. The are logically
    unordered (i.e. swapping makes no difference), but we require a
    rank on the Sequences, and so implicitly on the sides, so to avoid
    ambiguity we require that the side for side1 is less than that for
    side2.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name": "Join",
"fields": [{"doc": "", "type": {"doc": "", "type": "record", "name":
"Side", "fields": [{"doc": "", "type": {"doc": "", "type": "record",
"name": "Position", "fields": [{"default": null, "doc": "", "type":
["null", "string"], "name": "sequenceId"}, {"default": null, "doc":
"", "type": ["null", "string"], "name": "referenceName"}, {"doc": "",
"type": "long", "name": "position"}]}, "name": "base"}, {"doc": "",
"type": {"symbols": ["NEG_STRAND", "POS_STRAND"], "doc": "", "type":
"enum", "name": "Strand"}, "name": "strand"}]}, "name": "side1"},
{"doc": "", "type": "Side", "name": "side2"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "side1",
        "side2",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'side1': Side,
            'side2': Side,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'side1': Side,
            'side2': Side,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'side1', 'side2'
    ]

    def __init__(self, **kwargs):
        self.side1 = kwargs.get(
            'side1', None)
        """
        The lower-valued Side that this Join is joining.
        """
        self.side2 = kwargs.get(
            'side2', None)
        """
        The higher-valued Side, which this Join attaches to the side
        specified   by side1.
        """


class LinearAlignment(ProtocolElement):
    """
    A linear alignment can be represented by one CIGAR string.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"LinearAlignment", "fields": [{"doc": "", "type": {"doc": "", "type":
"record", "name": "Side", "fields": [{"doc": "", "type": {"doc": "",
"type": "record", "name": "Position", "fields": [{"default": null,
"doc": "", "type": ["null", "string"], "name": "sequenceId"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"referenceName"}, {"doc": "", "type": "long", "name": "position"}]},
"name": "base"}, {"doc": "", "type": {"symbols": ["NEG_STRAND",
"POS_STRAND"], "doc": "", "type": "enum", "name": "Strand"}, "name":
"strand"}]}, "name": "position"}, {"default": null, "doc": "", "type":
["null", "int"], "name": "mappingQuality"}, {"default": [], "doc": "",
"type": {"items": {"doc": "", "type": "record", "name": "CigarUnit",
"fields": [{"doc": "", "type": {"symbols": ["ALIGNMENT_MATCH",
"INSERT", "DELETE", "SKIP", "CLIP_SOFT", "CLIP_HARD", "PAD",
"SEQUENCE_MATCH", "SEQUENCE_MISMATCH"], "doc": "", "type": "enum",
"name": "CigarOperation"}, "name": "operation"}, {"doc": "", "type":
"long", "name": "operationLength"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "referenceSequence"}]}, "type":
"array"}, "name": "cigar"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "position",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'cigar': CigarUnit,
            'position': Side,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'cigar': CigarUnit,
            'position': Side,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'cigar', 'mappingQuality', 'position'
    ]

    def __init__(self, **kwargs):
        self.cigar = kwargs.get(
            'cigar', [])
        """
        Represents the local alignment of this sequence (alignment
        matches, indels, etc)   versus the reference.
        """
        self.mappingQuality = kwargs.get(
            'mappingQuality', None)
        """
        The mapping quality of this alignment. Represents how likely
        the read maps to this position as opposed to other locations.
        """
        self.position = kwargs.get(
            'position', None)
        """
        The position of this alignment.
        """


class ListReferenceBasesRequest(ProtocolElement):
    """
    The query parameters for a request to GET /references/{id}/bases,
    for example:  GET /references/{id}/bases?start=100&end=200
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"ListReferenceBasesRequest", "fields": [{"default": 0, "doc": "",
"type": "long", "name": "start"}, {"default": null, "doc": "", "type":
["null", "long"], "name": "end"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "pageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'end', 'pageToken', 'start'
    ]

    def __init__(self, **kwargs):
        self.end = kwargs.get(
            'end', None)
        """
        The end position (0-based, exclusive) of this query. Defaults
        to the length of this Reference.
        """
        self.pageToken = kwargs.get(
            'pageToken', None)
        """
        The continuation token, which is used to page through large
        result sets.   To get the next page of results, set this
        parameter to the value of   nextPageToken from the previous
        response.
        """
        self.start = kwargs.get(
            'start', 0)
        """
        The start position (0-based) of this query. Defaults to 0.
        Genomic positions are non-negative integers less than
        reference length.   Requests spanning the join of circular
        genomes are represented as   two requests one on each side of
        the join (position 0).
        """


class ListReferenceBasesResponse(ProtocolElement):
    """
    The response from GET /references/{id}/bases expressed as JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"ListReferenceBasesResponse", "fields": [{"default": 0, "doc": "",
"type": "long", "name": "offset"}, {"doc": "", "type": "string",
"name": "sequence"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "nextPageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "sequence",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'nextPageToken', 'offset', 'sequence'
    ]

    def __init__(self, **kwargs):
        self.nextPageToken = kwargs.get(
            'nextPageToken', None)
        """
        The continuation token, which is used to page through large
        result sets.   Provide this value in a subsequent request to
        return the next page of   results. This field will be empty if
        there aren't any additional results.
        """
        self.offset = kwargs.get(
            'offset', 0)
        """
        The offset position (0-based) of the given sequence from the
        start of this   Reference. This value will differ for each
        page in a paginated request.
        """
        self.sequence = kwargs.get(
            'sequence', None)
        """
        A substring of the bases that make up this reference. Bases
        are represented   as IUPAC-IUB codes; this string matches the
        regexp [ACGTMRWSYKVHDBN]*.
        """


class OntologyTerm(ProtocolElement):
    """
    An ontology term describing an attribute. (e.g. the phenotype
    attribute 'polydactyly' from HPO)
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"OntologyTerm", "fields": [{"doc": "", "type": "string", "name":
"ontologySource"}, {"doc": "", "type": "string", "name": "id"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"name"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "id",
        "ontologySource",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'id', 'name', 'ontologySource'
    ]

    def __init__(self, **kwargs):
        self.id = kwargs.get(
            'id', None)
        """
        The ID defined by the external onotology source.   (e.g.
        http://purl.obolibrary.org/obo/OBI_0001271)
        """
        self.name = kwargs.get(
            'name', None)
        """
        The name of the onotology term. (e.g. RNA-seq assay)
        """
        self.ontologySource = kwargs.get(
            'ontologySource', None)
        """
        The source of the onotology term.   (e.g. Ontology for
        Biomedical Investigation)
        """


class Path(ProtocolElement):
    """
    A Path is an ordered list of Segments. In general any contiguous
    path through a sequence graph, with no novel adjacencies, can be
    represented by a Path.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name": "Path",
"fields": [{"default": [], "doc": "", "type": {"items": {"doc": "",
"type": "record", "name": "Segment", "fields": [{"doc": "", "type":
{"doc": "", "type": "record", "name": "Side", "fields": [{"doc": "",
"type": {"doc": "", "type": "record", "name": "Position", "fields":
[{"default": null, "doc": "", "type": ["null", "string"], "name":
"sequenceId"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "referenceName"}, {"doc": "", "type": "long",
"name": "position"}]}, "name": "base"}, {"doc": "", "type":
{"symbols": ["NEG_STRAND", "POS_STRAND"], "doc": "", "type": "enum",
"name": "Strand"}, "name": "strand"}]}, "name": "start"}, {"doc": "",
"type": "long", "name": "length"}]}, "type": "array"}, "name":
"segments"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'segments': Segment,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'segments': Segment,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'segments'
    ]

    def __init__(self, **kwargs):
        self.segments = kwargs.get(
            'segments', [])
        """
        We require that each pair of consecutive Segments in a Path be
        connected   by a Join from the right end of the first Segment
        to the left end of the   second. Segments appear in the order
        in which they occur when walking the   path from one end to
        the other.    Note that the Path cannot follow two Joins in a
        row without traversing a   Segment.    Two adjacent Segments
        that could be combined must be combined. Adjacent   Segments
        should not be abutting on the same Sequence.    "Sticky ends",
        or Paths that start or end in a Join, are specified by   using
        a 0-length Segment at the start or end of the Path.
        """


class Position(ProtocolElement):
    """
    A Position is an unoriented base in some already known sequence. A
    Position is represented by a sequence name or ID, and a base
    number on that sequence (0-based).
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"Position", "fields": [{"default": null, "doc": "", "type": ["null",
"string"], "name": "sequenceId"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "referenceName"}, {"doc": "", "type":
"long", "name": "position"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "position",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'position', 'referenceName', 'sequenceId'
    ]

    def __init__(self, **kwargs):
        self.position = kwargs.get(
            'position', None)
        """
        The 0-based offset from the start of the forward strand for
        that sequence.   Genomic positions are non-negative integers
        less than sequence length.
        """
        self.referenceName = kwargs.get(
            'referenceName', None)
        """
        The name of the reference sequence in whatever reference set
        is being used.   Does not generally include a "chr" prefix, so
        for example "X" would be used   for the X chromosome.    If
        sequenceId is null, this must not be null.
        """
        self.sequenceId = kwargs.get(
            'sequenceId', None)
        """
        The ID of the sequence on which the Side is located. This may
        be a   Reference sequence, or a novel piece of sequence
        associated with a   VariantSet.    We allow a null value for
        sequenceId to support the "classic" model.    If the server
        supports the "graph" mode, this must not be null.
        """


class Program(ProtocolElement):
    """
    No documentation
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name": "Program",
"fields": [{"default": null, "doc": "", "type": ["null", "string"],
"name": "commandLine"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "id"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "name"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "prevProgramId"}, {"default":
null, "doc": "", "type": ["null", "string"], "name": "version"}]}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'commandLine', 'id', 'name', 'prevProgramId', 'version'
    ]

    def __init__(self, **kwargs):
        self.commandLine = kwargs.get(
            'commandLine', None)
        """
        The command line used to run this program.
        """
        self.id = kwargs.get(
            'id', None)
        """
        The user specified ID of the program.
        """
        self.name = kwargs.get(
            'name', None)
        """
        The name of the program.
        """
        self.prevProgramId = kwargs.get(
            'prevProgramId', None)
        """
        The ID of the program run before this one.
        """
        self.version = kwargs.get(
            'version', None)
        """
        The version of the program run.
        """


class QueryResource(ProtocolElement):
    """
    A request for information about a specific site
    """
    _schemaSource = """
{"namespace": "org.ga4gh.beacon", "type": "record", "name":
"QueryResource", "fields": [{"doc": "", "type": "string", "name":
"referenceBases"}, {"doc": "", "type": "string", "name":
"alternateBases"}, {"doc": "", "type": "string", "name":
"chromosome"}, {"doc": "", "type": "long", "name": "position"},
{"doc": "", "type": "string", "name": "reference"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "dataset"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "alternateBases",
        "chromosome",
        "position",
        "reference",
        "referenceBases",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'alternateBases', 'chromosome', 'dataset', 'position',
        'reference', 'referenceBases'
    ]

    def __init__(self, **kwargs):
        self.alternateBases = kwargs.get(
            'alternateBases', None)
        """
        The bases that appear instead of the reference bases. (see
        variants.avdl)
        """
        self.chromosome = kwargs.get(
            'chromosome', None)
        """
        The chromosome of the request
        """
        self.dataset = kwargs.get(
            'dataset', None)
        """
        The name of the targeted population
        """
        self.position = kwargs.get(
            'position', None)
        """
        0-based allele locus
        """
        self.reference = kwargs.get(
            'reference', None)
        """
        The version of the reference
        """
        self.referenceBases = kwargs.get(
            'referenceBases', None)
        """
        The reference bases for this variant, starting from position,
        in the genome   described by the field reference. (see
        variants.avdl)
        """


class ReadAlignment(ProtocolElement):
    """
    Each read alignment describes an alignment with additional
    information about the fragment and the read. A read alignment
    object is equivalent to a line in a SAM file.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"ReadAlignment", "fields": [{"doc": "", "type": ["null", "string"],
"name": "id"}, {"doc": "", "type": "string", "name": "readGroupId"},
{"doc": "", "type": "string", "name": "fragmentId"}, {"doc": "",
"type": "string", "name": "fragmentName"}, {"default": null, "doc":
"", "type": ["null", "boolean"], "name": "properPlacement"},
{"default": null, "doc": "", "type": ["null", "boolean"], "name":
"duplicateFragment"}, {"default": null, "doc": "", "type": ["null",
"int"], "name": "numberReads"}, {"default": null, "doc": "", "type":
["null", "int"], "name": "fragmentLength"}, {"default": null, "doc":
"", "type": ["null", "int"], "name": "readNumber"}, {"default": null,
"doc": "", "type": ["null", "boolean"], "name":
"failedVendorQualityChecks"}, {"default": null, "doc": "", "type":
["null", {"doc": "", "type": "record", "name": "LinearAlignment",
"fields": [{"doc": "", "type": {"doc": "", "type": "record", "name":
"Side", "fields": [{"doc": "", "type": {"doc": "", "type": "record",
"name": "Position", "fields": [{"default": null, "doc": "", "type":
["null", "string"], "name": "sequenceId"}, {"default": null, "doc":
"", "type": ["null", "string"], "name": "referenceName"}, {"doc": "",
"type": "long", "name": "position"}]}, "name": "base"}, {"doc": "",
"type": {"symbols": ["NEG_STRAND", "POS_STRAND"], "doc": "", "type":
"enum", "name": "Strand"}, "name": "strand"}]}, "name": "position"},
{"default": null, "doc": "", "type": ["null", "int"], "name":
"mappingQuality"}, {"default": [], "doc": "", "type": {"items":
{"doc": "", "type": "record", "name": "CigarUnit", "fields": [{"doc":
"", "type": {"symbols": ["ALIGNMENT_MATCH", "INSERT", "DELETE",
"SKIP", "CLIP_SOFT", "CLIP_HARD", "PAD", "SEQUENCE_MATCH",
"SEQUENCE_MISMATCH"], "doc": "", "type": "enum", "name":
"CigarOperation"}, "name": "operation"}, {"doc": "", "type": "long",
"name": "operationLength"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "referenceSequence"}]}, "type": "array"},
"name": "cigar"}]}], "name": "alignment"}, {"default": null, "doc":
"", "type": ["null", {"doc": "", "type": "record", "name":
"GraphAlignment", "fields": [{"doc": "", "type": {"doc": "", "type":
"record", "name": "Path", "fields": [{"default": [], "doc": "",
"type": {"items": {"doc": "", "type": "record", "name": "Segment",
"fields": [{"doc": "", "type": "Side", "name": "start"}, {"doc": "",
"type": "long", "name": "length"}]}, "type": "array"}, "name":
"segments"}]}, "name": "path"}, {"default": null, "doc": "", "type":
["null", "int"], "name": "mappingQuality"}, {"default": [], "doc": "",
"type": {"items": "CigarUnit", "type": "array"}, "name": "cigar"}]}],
"name": "graphAlignment"}, {"default": null, "doc": "", "type":
["null", "boolean"], "name": "secondaryAlignment"}, {"default": null,
"doc": "", "type": ["null", "boolean"], "name":
"supplementaryAlignment"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "alignedSequence"}, {"default": [], "doc":
"", "type": {"items": "int", "type": "array"}, "name":
"alignedQuality"}, {"default": null, "doc": "", "type": ["null",
"Side"], "name": "nextMatePosition"}, {"default": {}, "doc": "",
"type": {"values": {"items": "string", "type": "array"}, "type":
"map"}, "name": "info"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "fragmentId",
        "fragmentName",
        "id",
        "readGroupId",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'alignment': LinearAlignment,
            'graphAlignment': GraphAlignment,
            'nextMatePosition': Side,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'alignment': LinearAlignment,
            'graphAlignment': GraphAlignment,
            'nextMatePosition': Side,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'alignedQuality', 'alignedSequence', 'alignment',
        'duplicateFragment', 'failedVendorQualityChecks',
        'fragmentId', 'fragmentLength', 'fragmentName',
        'graphAlignment', 'id', 'info', 'nextMatePosition',
        'numberReads', 'properPlacement', 'readGroupId', 'readNumber',
        'secondaryAlignment', 'supplementaryAlignment'
    ]

    def __init__(self, **kwargs):
        self.alignedQuality = kwargs.get(
            'alignedQuality', [])
        """
        The quality of the read sequence contained in this alignment
        record.   alignedSequence and alignedQuality may be shorter
        than the full read sequence   and quality. This will occur if
        the alignment is part of a chimeric alignment,   or if the
        read was trimmed. When this occurs, the CIGAR for this read
        will   begin/end with a hard clip operator that will indicate
        the length of the excised sequence.
        """
        self.alignedSequence = kwargs.get(
            'alignedSequence', None)
        """
        The bases of the read sequence contained in this alignment
        record.   alignedSequence and alignedQuality may be shorter
        than the full read sequence   and quality. This will occur if
        the alignment is part of a chimeric alignment,   or if the
        read was trimmed. When this occurs, the CIGAR for this read
        will   begin/end with a hard clip operator that will indicate
        the length of the excised sequence.
        """
        self.alignment = kwargs.get(
            'alignment', None)
        """
        The alignment for this alignment record served by a server in
        "classic"   mode. This field will be null if the read is
        unmapped.    This attribute can only be non-null if
        graphAlignment is null.
        """
        self.duplicateFragment = kwargs.get(
            'duplicateFragment', None)
        """
        The fragment is a PCR or optical duplicate (SAM flag 0x400)
        """
        self.failedVendorQualityChecks = kwargs.get(
            'failedVendorQualityChecks', None)
        """
        SAM flag 0x200
        """
        self.fragmentId = kwargs.get(
            'fragmentId', None)
        """
        The fragment ID that this ReadAlignment belongs to.
        """
        self.fragmentLength = kwargs.get(
            'fragmentLength', None)
        """
        The observed length of the fragment, equivalent to TLEN in
        SAM.
        """
        self.fragmentName = kwargs.get(
            'fragmentName', None)
        """
        The fragment name. Equivalent to QNAME (query template name)
        in SAM.
        """
        self.graphAlignment = kwargs.get(
            'graphAlignment', None)
        """
        The alignment for this alignment record served by a server in
        "graph"   mode.    This attribute can only be non-null if
        alignment is null.
        """
        self.id = kwargs.get(
            'id', None)
        """
        The read alignment ID. This ID is unique within the read group
        this   alignment belongs to. This field may not be provided by
        all backends.   Its intended use is to make caching and UI
        display easier for   genome browsers and other light weight
        clients.
        """
        self.info = kwargs.get(
            'info', {})
        """
        A map of additional read alignment information.
        """
        self.nextMatePosition = kwargs.get(
            'nextMatePosition', None)
        """
        The mapping of the primary alignment of the
        (readNumber+1)%numberReads   read in the fragment. It replaces
        mate position and mate strand in SAM.
        """
        self.numberReads = kwargs.get(
            'numberReads', None)
        """
        The number of reads in the fragment (extension to SAM flag
        0x1)
        """
        self.properPlacement = kwargs.get(
            'properPlacement', None)
        """
        The orientation and the distance between reads from the
        fragment are   consistent with the sequencing protocol
        (equivalent to SAM flag 0x2)
        """
        self.readGroupId = kwargs.get(
            'readGroupId', None)
        """
        The ID of the read group this read belongs to.   (Every read
        must belong to exactly one read group.)
        """
        self.readNumber = kwargs.get(
            'readNumber', None)
        """
        The read number in sequencing. 0-based and less than
        numberReads. This field   replaces SAM flag 0x40 and 0x80.
        """
        self.secondaryAlignment = kwargs.get(
            'secondaryAlignment', None)
        """
        Whether this alignment is secondary. Equivalent to SAM flag
        0x100.   A secondary alignment represents an alternative to
        the primary alignment   for this read. Aligners may return
        secondary alignments if a read can map   ambiguously to
        multiple coordinates in the genome.    By convention, each
        read has one and only one alignment where both
        secondaryAlignment and supplementaryAlignment are false.
        """
        self.supplementaryAlignment = kwargs.get(
            'supplementaryAlignment', None)
        """
        Whether this alignment is supplementary. Equivalent to SAM
        flag 0x800.   Supplementary alignments are used in the
        representation of a chimeric   alignment, which follows
        nonreference adjacencies not describable as indels.   In a
        chimeric alignment, a read is split into multiple alignments
        that   may map to different reference contigs. The first
        alignment in the read will   be designated as the
        representative alignment; the remaining alignments will   be
        designated as supplementary alignments. These alignments may
        have different   mapping quality scores.    In each alignment
        in a chimeric alignment, the read will be hard clipped. The
        alignedSequence and alignedQuality fields in the alignment
        record will   only represent the bases for its respective
        alignment.
        """


class ReadCounts(ProtocolElement):
    """
    Details of the read counts.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"ReadCounts", "fields": [{"doc": "", "type": "string", "name":
"analysisId"}, {"doc": "", "type": "int", "name": "totalReadCount"},
{"doc": "", "type": "int", "name": "uniqueCount"}, {"doc": "", "type":
"int", "name": "multiCount"}, {"doc": "", "type": "int", "name":
"uniqueSpliceCount"}, {"doc": "", "type": "int", "name":
"multiSpliceCount"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "analysisId",
        "multiCount",
        "multiSpliceCount",
        "totalReadCount",
        "uniqueCount",
        "uniqueSpliceCount",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'analysisId', 'multiCount', 'multiSpliceCount',
        'totalReadCount', 'uniqueCount', 'uniqueSpliceCount'
    ]

    def __init__(self, **kwargs):
        self.analysisId = kwargs.get(
            'analysisId', None)
        """
        The associated RnaQuantification.
        """
        self.multiCount = kwargs.get(
            'multiCount', None)
        """
        Total number of reads that map to multiple positions in the
        reference.
        """
        self.multiSpliceCount = kwargs.get(
            'multiSpliceCount', None)
        """
        Total number of reads that map to multiple splice positions in
        the reference.
        """
        self.totalReadCount = kwargs.get(
            'totalReadCount', None)
        """
        Total number of mapped reads.
        """
        self.uniqueCount = kwargs.get(
            'uniqueCount', None)
        """
        Total number of reads that are uniquely mapped to a position
        in the reference.
        """
        self.uniqueSpliceCount = kwargs.get(
            'uniqueSpliceCount', None)
        """
        Total number of reads that are uniquely mapped to a splice
        position in the reference.
        """


class ReadGroup(ProtocolElement):
    """
    No documentation
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"ReadGroup", "fields": [{"doc": "", "type": "string", "name": "id"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"datasetId"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "name"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "description"}, {"doc": "", "type": ["null",
"string"], "name": "sampleId"}, {"doc": "", "type": ["null", {"doc":
"", "type": "record", "name": "Experiment", "fields": [{"doc": "",
"type": "string", "name": "id"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "name"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "description"}, {"doc": "",
"type": "string", "name": "recordCreateTime"}, {"doc": "", "type":
"string", "name": "recordUpdateTime"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "runTime"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "molecule"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"strategy"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "selection"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "library"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "libraryLayout"}, {"doc": "", "type":
["null", "string"], "name": "instrumentModel"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "instrumentDataFile"},
{"doc": "", "type": ["null", "string"], "name": "sequencingCenter"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"platformUnit"}, {"default": {}, "doc": "", "type": {"values":
{"items": "string", "type": "array"}, "type": "map"}, "name":
"info"}]}], "name": "experiment"}, {"default": null, "doc": "",
"type": ["null", "int"], "name": "predictedInsertSize"}, {"default":
null, "doc": "", "type": ["null", "long"], "name": "created"},
{"default": null, "doc": "", "type": ["null", "long"], "name":
"updated"}, {"default": null, "doc": "", "type": ["null", {"fields":
[{"default": null, "doc": "", "type": ["null", "long"], "name":
"alignedReadCount"}, {"default": null, "doc": "", "type": ["null",
"long"], "name": "unalignedReadCount"}, {"default": null, "doc": "",
"type": ["null", "long"], "name": "baseCount"}], "type": "record",
"name": "ReadStats"}], "name": "stats"}, {"default": [], "doc": "",
"type": {"items": {"fields": [{"default": null, "doc": "", "type":
["null", "string"], "name": "commandLine"}, {"default": null, "doc":
"", "type": ["null", "string"], "name": "id"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "name"}, {"default":
null, "doc": "", "type": ["null", "string"], "name": "prevProgramId"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"version"}], "type": "record", "name": "Program"}, "type": "array"},
"name": "programs"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "referenceSetId"}, {"default": {}, "doc": "",
"type": {"values": {"items": "string", "type": "array"}, "type":
"map"}, "name": "info"}]}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "experiment",
        "id",
        "sampleId",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'experiment': Experiment,
            'programs': Program,
            'stats': ReadStats,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'experiment': Experiment,
            'programs': Program,
            'stats': ReadStats,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'created', 'datasetId', 'description', 'experiment', 'id',
        'info', 'name', 'predictedInsertSize', 'programs',
        'referenceSetId', 'sampleId', 'stats', 'updated'
    ]

    def __init__(self, **kwargs):
        self.created = kwargs.get(
            'created', None)
        """
        The time at which this read group was created in milliseconds
        from the epoch.
        """
        self.datasetId = kwargs.get(
            'datasetId', None)
        """
        The ID of the dataset this read group belongs to.
        """
        self.description = kwargs.get(
            'description', None)
        """
        The read group description.
        """
        self.experiment = kwargs.get(
            'experiment', None)
        """
        The experiment used to generate this read group.
        """
        self.id = kwargs.get(
            'id', None)
        """
        The read group ID.
        """
        self.info = kwargs.get(
            'info', {})
        """
        A map of additional read group information.
        """
        self.name = kwargs.get(
            'name', None)
        """
        The read group name.
        """
        self.predictedInsertSize = kwargs.get(
            'predictedInsertSize', None)
        """
        The predicted insert size of this read group.
        """
        self.programs = kwargs.get(
            'programs', [])
        """
        The programs used to generate this read group.
        """
        self.referenceSetId = kwargs.get(
            'referenceSetId', None)
        """
        The reference set the reads in this read group are aligned to.
        Required if there are any read alignments.
        """
        self.sampleId = kwargs.get(
            'sampleId', None)
        """
        The sample this read group's data was generated from.
        """
        self.stats = kwargs.get(
            'stats', None)
        """
        Statistical data on reads in this read group.
        """
        self.updated = kwargs.get(
            'updated', None)
        """
        The time at which this read group was last updated in
        milliseconds   from the epoch.
        """


class ReadGroupSet(ProtocolElement):
    """
    No documentation
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"ReadGroupSet", "fields": [{"doc": "", "type": "string", "name":
"id"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "datasetId"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "name"}, {"default": null, "doc": "", "type":
["null", {"fields": [{"default": null, "doc": "", "type": ["null",
"long"], "name": "alignedReadCount"}, {"default": null, "doc": "",
"type": ["null", "long"], "name": "unalignedReadCount"}, {"default":
null, "doc": "", "type": ["null", "long"], "name": "baseCount"}],
"type": "record", "name": "ReadStats"}], "name": "stats"}, {"default":
[], "doc": "", "type": {"items": {"fields": [{"doc": "", "type":
"string", "name": "id"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "datasetId"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "name"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "description"}, {"doc": "",
"type": ["null", "string"], "name": "sampleId"}, {"doc": "", "type":
["null", {"doc": "", "type": "record", "name": "Experiment", "fields":
[{"doc": "", "type": "string", "name": "id"}, {"default": null, "doc":
"", "type": ["null", "string"], "name": "name"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "description"}, {"doc":
"", "type": "string", "name": "recordCreateTime"}, {"doc": "", "type":
"string", "name": "recordUpdateTime"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "runTime"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "molecule"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"strategy"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "selection"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "library"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "libraryLayout"}, {"doc": "", "type":
["null", "string"], "name": "instrumentModel"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "instrumentDataFile"},
{"doc": "", "type": ["null", "string"], "name": "sequencingCenter"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"platformUnit"}, {"default": {}, "doc": "", "type": {"values":
{"items": "string", "type": "array"}, "type": "map"}, "name":
"info"}]}], "name": "experiment"}, {"default": null, "doc": "",
"type": ["null", "int"], "name": "predictedInsertSize"}, {"default":
null, "doc": "", "type": ["null", "long"], "name": "created"},
{"default": null, "doc": "", "type": ["null", "long"], "name":
"updated"}, {"default": null, "doc": "", "type": ["null",
"ReadStats"], "name": "stats"}, {"default": [], "doc": "", "type":
{"items": {"fields": [{"default": null, "doc": "", "type": ["null",
"string"], "name": "commandLine"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "id"}, {"default": null, "doc":
"", "type": ["null", "string"], "name": "name"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "prevProgramId"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"version"}], "type": "record", "name": "Program"}, "type": "array"},
"name": "programs"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "referenceSetId"}, {"default": {}, "doc": "",
"type": {"values": {"items": "string", "type": "array"}, "type":
"map"}, "name": "info"}], "type": "record", "name": "ReadGroup"},
"type": "array"}, "name": "readGroups"}]}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "id",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'readGroups': ReadGroup,
            'stats': ReadStats,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'readGroups': ReadGroup,
            'stats': ReadStats,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'datasetId', 'id', 'name', 'readGroups', 'stats'
    ]

    def __init__(self, **kwargs):
        self.datasetId = kwargs.get(
            'datasetId', None)
        """
        The ID of the dataset this read group set belongs to.
        """
        self.id = kwargs.get(
            'id', None)
        """
        The read group set ID.
        """
        self.name = kwargs.get(
            'name', None)
        """
        The read group set name.
        """
        self.readGroups = kwargs.get(
            'readGroups', [])
        """
        The read groups in this set.
        """
        self.stats = kwargs.get(
            'stats', None)
        """
        Statistical data on reads in this read group set.
        """


class ReadStats(ProtocolElement):
    """
    No documentation
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"ReadStats", "fields": [{"default": null, "doc": "", "type": ["null",
"long"], "name": "alignedReadCount"}, {"default": null, "doc": "",
"type": ["null", "long"], "name": "unalignedReadCount"}, {"default":
null, "doc": "", "type": ["null", "long"], "name": "baseCount"}]}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'alignedReadCount', 'baseCount', 'unalignedReadCount'
    ]

    def __init__(self, **kwargs):
        self.alignedReadCount = kwargs.get(
            'alignedReadCount', None)
        """
        The number of aligned reads.
        """
        self.baseCount = kwargs.get(
            'baseCount', None)
        """
        The total number of bases.   This is equivalent to the sum of
        alignedSequence.length for all reads.
        """
        self.unalignedReadCount = kwargs.get(
            'unalignedReadCount', None)
        """
        The number of unaligned reads.
        """


class Reference(ProtocolElement):
    """
    A Reference is a canonical assembled contig, intended to act as a
    reference coordinate space for other genomic annotations. A single
    Reference might represent the human chromosome 1, for instance.
    References are designed to be immutable. When extending a
    ReferenceSet with new References, the existing References should
    not be changed. Newly added Reference Sequences may be children of
    existing Reference Sequences, but existing Reference Sequences
    should not be made to be children of newly added Reference
    Sequences.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"Reference", "fields": [{"doc": "", "type": "string", "name": "id"},
{"doc": "", "type": "string", "name": "sequenceId"}, {"doc": "",
"type": "long", "name": "start"}, {"doc": "", "type": "long", "name":
"length"}, {"doc": "", "type": "string", "name": "md5checksum"},
{"doc": "", "type": "string", "name": "name"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "sourceURI"}, {"doc":
"", "type": {"items": "string", "type": "array"}, "name":
"sourceAccessions"}, {"default": false, "doc": "", "type": "boolean",
"name": "isDerived"}, {"default": null, "doc": "", "type": ["null",
"float"], "name": "sourceDivergence"}, {"default": null, "doc": "",
"type": ["null", "int"], "name": "ncbiTaxonId"}, {"default": true,
"doc": "", "type": "boolean", "name": "isPrimary"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "id",
        "length",
        "md5checksum",
        "name",
        "sequenceId",
        "sourceAccessions",
        "start",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'id', 'isDerived', 'isPrimary', 'length', 'md5checksum',
        'name', 'ncbiTaxonId', 'sequenceId', 'sourceAccessions',
        'sourceDivergence', 'sourceURI', 'start'
    ]

    def __init__(self, **kwargs):
        self.id = kwargs.get(
            'id', None)
        """
        The reference ID. Unique within the repository.
        """
        self.isDerived = kwargs.get(
            'isDerived', False)
        """
        A sequence X is said to be derived from source sequence Y, if
        X and Y   are of the same length and the per-base sequence
        divergence at A/C/G/T bases   is sufficiently small. Two
        sequences derived from the same official   sequence share the
        same coordinates and annotations, and   can be replaced with
        the official sequence for certain use cases.
        """
        self.isPrimary = kwargs.get(
            'isPrimary', True)
        """
        whether this reference is primary, part of the core coordinate
        system, or not
        """
        self.length = kwargs.get(
            'length', None)
        """
        The number of bases in this Reference. This will be the length
        of the   Reference's Sequence unless the Sequence has some
        bases at one or both   ends not included in the Reference.
        """
        self.md5checksum = kwargs.get(
            'md5checksum', None)
        """
        The MD5 checksum uniquely representing this Reference as a
        lower-case   hexadecimal string, calculated as the MD5 of the
        upper-case sequence   excluding all whitespace characters
        (this is equivalent to SQ:M5 in SAM).
        """
        self.name = kwargs.get(
            'name', None)
        """
        The name of this reference. (e.g. '22').
        """
        self.ncbiTaxonId = kwargs.get(
            'ncbiTaxonId', None)
        """
        ID from http://www.ncbi.nlm.nih.gov/taxonomy (e.g.
        9606->human).
        """
        self.sequenceId = kwargs.get(
            'sequenceId', None)
        """
        The ID of the Sequence on which this Reference occurs. May not
        be null,   although it may happen to be the same as the ID of
        the Reference.    The actual Sequence bases for a Reference
        are available through the   getSequenceBases() API call on
        this Reference's Sequence.    Multiple References on the same
        Sequence may not overlap.
        """
        self.sourceAccessions = kwargs.get(
            'sourceAccessions', None)
        """
        All known corresponding accession IDs in INSDC
        (GenBank/ENA/DDBJ) ideally   with a version number, e.g.
        GCF_000001405.26.
        """
        self.sourceDivergence = kwargs.get(
            'sourceDivergence', None)
        """
        The sourceDivergence is the fraction of non-indel bases that
        do not match the   reference this record was derived from.
        """
        self.sourceURI = kwargs.get(
            'sourceURI', None)
        """
        The URI from which the sequence was obtained.   Specifies a
        FASTA format file/string with one name, sequence pair.   In
        most cases, clients should call the getSequenceBases() or
        getReferenceBases() methods to obtain sequence bases for a
        Reference   instead of attempting to retrieve this URI.
        """
        self.start = kwargs.get(
            'start', None)
        """
        The 0-based inclusive offset from the left end of the Sequence
        at which the   Reference begins. This will be 0 unless the
        Sequence contains bases at the   left not included in the
        Reference.
        """


class ReferenceSet(ProtocolElement):
    """
    A ReferenceSet is a set of References which typically comprise a
    reference assembly, such as GRCh38. A ReferenceSet defines a
    common coordinate space for comparing reference-aligned
    experimental data.  ReferenceSets are composeable: a ReferenceSet
    may incorporate all of the References and Joins from one or more
    other ReferenceSets via the includedReferenceSets array.  In
    classic mode, this is just a set of sequences.  In graph mode,
    there are both sequences and joins, but we only access the joins
    via method getReferenceJoins().
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"ReferenceSet", "fields": [{"doc": "", "type": "string", "name":
"id"}, {"default": null, "doc": "", "type": ["null", {"items":
"string", "type": "array"}], "name": "referenceIds"}, {"default": [],
"doc": "", "type": {"items": "string", "type": "array"}, "name":
"includedReferenceSets"}, {"doc": "", "type": "string", "name":
"md5checksum"}, {"default": null, "doc": "", "type": ["null", "int"],
"name": "ncbiTaxonId"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "description"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "assemblyId"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "sourceURI"}, {"doc":
"", "type": {"items": "string", "type": "array"}, "name":
"sourceAccessions"}, {"default": false, "doc": "", "type": "boolean",
"name": "isDerived"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "id",
        "md5checksum",
        "sourceAccessions",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'assemblyId', 'description', 'id', 'includedReferenceSets',
        'isDerived', 'md5checksum', 'ncbiTaxonId', 'referenceIds',
        'sourceAccessions', 'sourceURI'
    ]

    def __init__(self, **kwargs):
        self.assemblyId = kwargs.get(
            'assemblyId', None)
        """
        Public id of this reference set, such as GRCh37.
        """
        self.description = kwargs.get(
            'description', None)
        """
        Optional free text description of this reference set.
        """
        self.id = kwargs.get(
            'id', None)
        """
        The reference set ID. Unique in the repository.
        """
        self.includedReferenceSets = kwargs.get(
            'includedReferenceSets', [])
        """
        The IDs of ReferenceSets that are included in this set,
        allowing extension   from a core e.g. provided by GRC or
        another provider.  In particular this   may provide a basis of
        primary references for a graph mode reference set.    A
        ReferenceSet is not allowed to include itself, either directly
        by ID, or   indirectly or transitively through another
        ReferenceSet.    References and Joins from the included
        ReferenceSets are considered to   be part of this one. If
        multiple included ReferenceSets provide a   Reference or Join,
        only one copy is taken to exist in this ReferenceSet.   Since
        different References on a Sequence may not overlap, it is
        illegal to   include ReferenceSets which when taken together
        would create such an   overlap, or to have such an overlap
        between a Reference from an included   ReferenceSet and one
        that appears directly in this ReferenceSet.
        """
        self.isDerived = kwargs.get(
            'isDerived', False)
        """
        A reference set may be derived from a source if it contains
        additional Sequences, or some of the Sequences within it are
        derived   (see the definition of isDerived in Reference).
        """
        self.md5checksum = kwargs.get(
            'md5checksum', None)
        """
        Order-independent MD5 checksum which identifies this
        ReferenceSet.    To compute this checksum, make a list of
        Reference.md5checksum for all   References in this set,
        including any in any included set. Add to that list   a lower-
        case MD5 checksum for each Join in the ReferenceSet or any
        included set, which is calculated by hashing the md5checksum,
        position as a   decimal string, and strand as "+" or "-" for
        the two Sides of the Join   in order. Then sort that list, and
        take the MD5 hash of all the strings   concatenated together.
        Express the hash as a lower-case hexadecimal string.
        """
        self.ncbiTaxonId = kwargs.get(
            'ncbiTaxonId', None)
        """
        ID from http://www.ncbi.nlm.nih.gov/taxonomy (e.g.
        9606->human) indicating   the species which this assembly is
        intended to model. Note that contained   References may
        specify a different ncbiTaxonId, as assemblies may   contain
        reference Sequences which do not belong to the modeled
        species, e.g.   EBV in a human reference genome.
        """
        self.referenceIds = kwargs.get(
            'referenceIds', None)
        """
        The IDs of the Reference objects that are part of this set.
        This field should be left null if the set contains a very
        large number of   References. The References in the set may
        also be obtained through a   searchReferences() API call.
        """
        self.sourceAccessions = kwargs.get(
            'sourceAccessions', None)
        """
        All known corresponding accession IDs in INSDC
        (GenBank/ENA/DDBJ) ideally   with a version number, e.g.
        NC_000001.11.
        """
        self.sourceURI = kwargs.get(
            'sourceURI', None)
        """
        Specifies a FASTA format file/string.
        """


class Region(ProtocolElement):
    """
    An abstraction for referring to a genomic region, in relation to
    some already  known reference. This will require some significant
    rework as we move to graph coordinates.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name": "Region",
"fields": [{"doc": "", "type": {"doc": "", "type": "record", "name":
"Position", "fields": [{"default": null, "doc": "", "type": ["null",
"string"], "name": "sequenceId"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "referenceName"}, {"doc": "", "type":
"long", "name": "position"}]}, "name": "start"}, {"doc": "", "type":
"long", "name": "length"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "length",
        "start",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'start': Position,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'start': Position,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'length', 'start'
    ]

    def __init__(self, **kwargs):
        self.length = kwargs.get(
            'length', None)
        """
        The length, in base pairs
        """
        self.start = kwargs.get(
            'start', None)
        """
        The starting point of the region. For the moment the base-pair
        included in   the region, on the 5' end of the oriented
        region.
        """


class ResponseResource(ProtocolElement):
    """
    The response to the Beacon query
    """
    _schemaSource = """
{"namespace": "org.ga4gh.beacon", "type": "record", "name":
"ResponseResource", "fields": [{"doc": "", "type": "string", "name":
"exists"}, {"doc": "", "type": ["null", "double"], "name":
"frequency"}, {"default": null, "doc": "", "type": ["null", "int"],
"name": "observed"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "info"}, {"default": null, "doc": "", "type":
["null", {"doc": "", "type": "record", "name": "ErrorResource",
"fields": [{"doc": "", "type": "string", "name": "name"}, {"default":
null, "doc": "", "type": ["null", "string"], "name":
"description"}]}], "name": "err"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "exists",
        "frequency",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'err': ErrorResource,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'err': ErrorResource,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'err', 'exists', 'frequency', 'info', 'observed'
    ]

    def __init__(self, **kwargs):
        self.err = kwargs.get(
            'err', None)
        """
        Error details. Provided if a beacon encountered an error.
        """
        self.exists = kwargs.get(
            'exists', None)
        """
        Whether the beacon has observed variants. True if an
        observation exactly matches request. Overlap if an
        observation overlaps request, but not exactly, as in the case
        of indels or if the query used wildcard for   allele. False if
        data are present at the requested position but no observations
        exactly match or overlap. Null   otherwise.
        """
        self.frequency = kwargs.get(
            'frequency', None)
        """
        Frequency of this allele in the dataset. Between 0 and 1,
        inclusive.
        """
        self.info = kwargs.get(
            'info', None)
        """
        Additional message. OK if request succeeded.
        """
        self.observed = kwargs.get(
            'observed', None)
        """
        Number of observations of this allele in the dataset.
        """


class RnaQuantification(ProtocolElement):
    """
    Top level identifying information
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"RnaQuantification", "fields": [{"doc": "", "type": "string", "name":
"id"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "name"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "description"}, {"doc": "", "type": "string",
"name": "readGroupId"}, {"default": [], "doc": "", "type": {"items":
"string", "type": "array"}, "name": "programIds"}, {"default": [],
"doc": "", "type": {"items": "string", "type": "array"}, "name":
"annotationIds"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "id",
        "readGroupId",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'annotationIds', 'description', 'id', 'name', 'programIds',
        'readGroupId'
    ]

    def __init__(self, **kwargs):
        self.annotationIds = kwargs.get(
            'annotationIds', [])
        """
        List of annotations used.
        """
        self.description = kwargs.get(
            'description', None)
        """
        Description
        """
        self.id = kwargs.get(
            'id', None)
        """
        The unique ID assigned to the results of running the described
        programs on the specified reads and assignment to the listed
        annotation.
        """
        self.name = kwargs.get(
            'name', None)
        """
        Name
        """
        self.programIds = kwargs.get(
            'programIds', [])
        """
        List of programIds used in the analysis.
        """
        self.readGroupId = kwargs.get(
            'readGroupId', None)
        """
        ID of the ReadGroup providing the reads for the analysis.
        """


class Sample(ProtocolElement):
    """
    A biological sample used in an experiment. (e.g. whole blood from
    an affected individual)
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name": "Sample",
"fields": [{"doc": "", "type": "string", "name": "id"}, {"default":
null, "doc": "", "type": ["null", "string"], "name": "individualId"},
{"default": [], "doc": "", "type": {"items": "string", "type":
"array"}, "name": "accessions"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "name"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "description"}, {"doc": "",
"type": "string", "name": "recordCreateTime"}, {"doc": "", "type":
"string", "name": "recordUpdateTime"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "samplingDate"}, {"default": null,
"doc": "", "type": ["null", "long"], "name": "ageAtSampling"},
{"default": null, "doc": "", "type": ["null", {"doc": "", "type":
"record", "name": "OntologyTerm", "fields": [{"default": null, "doc":
"", "type": ["null", "string"], "name": "ontologySourceName"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"ontologySourceID"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "ontologySourceVersion"}]}], "name": "cellType"},
{"default": null, "doc": "", "type": ["null", "OntologyTerm"], "name":
"cellLine"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "geocode"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "sampleType"}, {"default": null, "doc": "", "type":
["null", "OntologyTerm"], "name": "organismPart"}, {"default": {},
"doc": "", "type": {"values": {"items": "string", "type": "array"},
"type": "map"}, "name": "info"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "id",
        "recordCreateTime",
        "recordUpdateTime",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'cellLine': OntologyTerm,
            'cellType': OntologyTerm,
            'organismPart': OntologyTerm,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'cellLine': OntologyTerm,
            'cellType': OntologyTerm,
            'organismPart': OntologyTerm,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'accessions', 'ageAtSampling', 'cellLine', 'cellType',
        'description', 'geocode', 'id', 'individualId', 'info',
        'name', 'organismPart', 'recordCreateTime',
        'recordUpdateTime', 'sampleType', 'samplingDate'
    ]

    def __init__(self, **kwargs):
        self.accessions = kwargs.get(
            'accessions', [])
        """
        Public identifiers for this sample.
        """
        self.ageAtSampling = kwargs.get(
            'ageAtSampling', None)
        """
        The age of the individual (not of the sample) at time of
        sample collection.   This field may be approximate.   TODO:
        Fixed unit? Years would be natural in human context.
        """
        self.cellLine = kwargs.get(
            'cellLine', None)
        """
        The cell line of this sample.    Using the [Cell Line
        Ontology](https://code.google.com/p/clo-ontology/) is a
        possibility.   TODO: discuss further. Other possibilities:
        Cellosaurus (nextprot), BRENDA/BTO, EFO (EBI)
        """
        self.cellType = kwargs.get(
            'cellType', None)
        """
        The cell type of this sample.   Using the [Cell
        Ontology](http://cellontology.org/) (CL) is recommended. See
        """
        self.description = kwargs.get(
            'description', None)
        """
        A description of the sample.
        """
        self.geocode = kwargs.get(
            'geocode', None)
        """
        Geographic coordinates from which the individual was obtained.
        TODO: Figure out the right type for this field.
        """
        self.id = kwargs.get(
            'id', None)
        """
        The sample UUID. This is globally unique.
        """
        self.individualId = kwargs.get(
            'individualId', None)
        """
        The ID of the individual this sample belongs to.
        """
        self.info = kwargs.get(
            'info', {})
        """
        A map of additional sample information.
        """
        self.name = kwargs.get(
            'name', None)
        """
        The name of the sample.
        """
        self.organismPart = kwargs.get(
            'organismPart', None)
        """
        The anatomical part of the individual from which this sample
        derives.   Using [Uberon](http://uberon.org) is recommended.
        """
        self.recordCreateTime = kwargs.get(
            'recordCreateTime', None)
        """
        The time at which this record was created.    Format: ISO
        8601, YYYY-MM-DDTHH:MM:SS.SSS (e.g. 2015-02-10T00:03:42.123Z)
        """
        self.recordUpdateTime = kwargs.get(
            'recordUpdateTime', None)
        """
        The time at which this record was last updated.   Format: ISO
        8601, YYYY-MM-DDTHH:MM:SS.SSS (e.g. 2015-02-10T00:03:42.123Z)
        """
        self.sampleType = kwargs.get(
            'sampleType', None)
        """
        A descriptor of the sample type. (e.g. frozen)
        """
        self.samplingDate = kwargs.get(
            'samplingDate', None)
        """
        The time at which this sample was taken from the individual.
        Granularity here is variabel (e.g. only date would be common
        for    biopsies, minutes for in vitro time series).   Format:
        ISO 8601, YYYY-MM-DDTHH:MM:SS (e.g. 2015-02-10T00:03:42)
        """


class SearchAllelesRequest(SearchRequest):
    """
    This request maps to the body of POST /alleles/search as JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchAllelesRequest", "fields": [{"doc": "", "type": "string",
"name": "variantSetId"}, {"doc": "", "type": "string", "name":
"sequenceId"}, {"doc": "", "type": "long", "name": "start"}, {"doc":
"", "type": "long", "name": "end"}, {"default": null, "doc": "",
"type": ["null", "int"], "name": "pageSize"}, {"default": null, "doc":
"", "type": ["null", "string"], "name": "pageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "end",
        "sequenceId",
        "start",
        "variantSetId",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'end', 'pageSize', 'pageToken', 'sequenceId', 'start',
        'variantSetId'
    ]

    def __init__(self, **kwargs):
        self.end = kwargs.get(
            'end', None)
        """
        Required. The end of the window (0-based, exclusive) for which
        overlapping   alleles should be returned.
        """
        self.pageSize = kwargs.get(
            'pageSize', None)
        """
        Specifies the maximum number of results to return in a single
        page.   If unspecified, a system default will be used.
        """
        self.pageToken = kwargs.get(
            'pageToken', None)
        """
        The continuation token, which is used to page through large
        result sets.   To get the next page of results, set this
        parameter to the value of   nextPageToken from the previous
        response.
        """
        self.sequenceId = kwargs.get(
            'sequenceId', None)
        """
        Required. Only return Alleles on the sequence with this ID.
        """
        self.start = kwargs.get(
            'start', None)
        """
        Required. The beginning of the window (0-based, inclusive) for
        which overlapping alleles should be returned.   Genomic
        positions are non-negative integers less than segment length.
        Requests spanning the join of circular genomes are represented
        as   two requests one on each side of the join (position 0).
        """
        self.variantSetId = kwargs.get(
            'variantSetId', None)
        """
        The VariantSet to search.
        """


class SearchAllelesResponse(SearchResponse):
    """
    This is the response from POST /alleles/search expressed as JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchAllelesResponse", "fields": [{"default": [], "doc": "", "type":
{"items": {"namespace": "org.ga4gh.models", "type": "record", "name":
"Allele", "fields": [{"doc": "", "type": "string", "name": "id"},
{"doc": "", "type": "string", "name": "variantSetId"}, {"doc": "",
"type": {"doc": "", "type": "record", "name": "Path", "fields":
[{"default": [], "doc": "", "type": {"items": {"doc": "", "type":
"record", "name": "Segment", "fields": [{"doc": "", "type": {"doc":
"", "type": "record", "name": "Side", "fields": [{"doc": "", "type":
{"doc": "", "type": "record", "name": "Position", "fields":
[{"default": null, "doc": "", "type": ["null", "string"], "name":
"sequenceId"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "referenceName"}, {"doc": "", "type": "long",
"name": "position"}]}, "name": "base"}, {"doc": "", "type":
{"symbols": ["NEG_STRAND", "POS_STRAND"], "doc": "", "type": "enum",
"name": "Strand"}, "name": "strand"}]}, "name": "start"}, {"doc": "",
"type": "long", "name": "length"}]}, "type": "array"}, "name":
"segments"}]}, "name": "path"}], "doc": ""}, "type": "array"}, "name":
"alleles"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "nextPageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])
    _valueListName = "alleles"

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'alleles': Allele,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'alleles': Allele,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'alleles', 'nextPageToken'
    ]

    def __init__(self, **kwargs):
        self.alleles = kwargs.get(
            'alleles', [])
        """
        The list of matching alleles. An Allele should be returned if
        a Segment   in its Path overlaps with the specified range.
        """
        self.nextPageToken = kwargs.get(
            'nextPageToken', None)
        """
        The continuation token, which is used to page through large
        result sets.   Provide this value in a subsequent request to
        return the next page of   results. This field will be empty if
        there aren't any additional results.
        """


class SearchAnalysesRequest(SearchRequest):
    """
    This request maps to the body of POST /analyses/search as JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchAnalysesRequest", "fields": [{"default": null, "doc": "",
"type": ["null", "string"], "name": "name"}, {"default": null, "doc":
"", "type": ["null", "int"], "name": "pageSize"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "pageToken"}], "doc":
""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'name', 'pageSize', 'pageToken'
    ]

    def __init__(self, **kwargs):
        self.name = kwargs.get(
            'name', None)
        """
        Only return analyses with this name (case-sensitive, exact
        match).
        """
        self.pageSize = kwargs.get(
            'pageSize', None)
        """
        Specifies the maximum number of results to return in a single
        page.   If unspecified, a system default will be used.
        """
        self.pageToken = kwargs.get(
            'pageToken', None)
        """
        The continuation token, which is used to page through large
        result sets.   To get the next page of results, set this
        parameter to the value of   nextPageToken from the previous
        response.
        """


class SearchAnalysesResponse(SearchResponse):
    """
    This is the response from POST /analyses/search expressed as JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchAnalysesResponse", "fields": [{"default": [], "doc": "",
"type": {"items": {"namespace": "org.ga4gh.models", "type": "record",
"name": "Analysis", "fields": [{"doc": "", "type": "string", "name":
"id"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "name"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "description"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "recordCreateTime"}, {"doc": "",
"type": "string", "name": "recordUpdateTime"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "type"}, {"default":
[], "doc": "", "type": {"items": "string", "type": "array"}, "name":
"software"}, {"default": {}, "doc": "", "type": {"values": {"items":
"string", "type": "array"}, "type": "map"}, "name": "info"}], "doc":
""}, "type": "array"}, "name": "analyses"}, {"default": null, "doc":
"", "type": ["null", "string"], "name": "nextPageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])
    _valueListName = "analyses"

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'analyses': Analysis,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'analyses': Analysis,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'analyses', 'nextPageToken'
    ]

    def __init__(self, **kwargs):
        self.analyses = kwargs.get(
            'analyses', [])
        """
        The list of matching analyses.
        """
        self.nextPageToken = kwargs.get(
            'nextPageToken', None)
        """
        The continuation token, which is used to page through large
        result sets.   Provide this value in a subsequent request to
        return the next page of   results. This field will be empty if
        there aren't any additional results.
        """


class SearchCallSetsRequest(SearchRequest):
    """
    This request maps to the body of POST /callsets/search as JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchCallSetsRequest", "fields": [{"doc": "", "type": "string",
"name": "variantSetId"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "name"}, {"default": null, "doc": "", "type":
["null", "int"], "name": "pageSize"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "pageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "variantSetId",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'name', 'pageSize', 'pageToken', 'variantSetId'
    ]

    def __init__(self, **kwargs):
        self.name = kwargs.get(
            'name', None)
        """
        Only return call sets with this name (case-sensitive, exact
        match).
        """
        self.pageSize = kwargs.get(
            'pageSize', None)
        """
        Specifies the maximum number of results to return in a single
        page.   If unspecified, a system default will be used.
        """
        self.pageToken = kwargs.get(
            'pageToken', None)
        """
        The continuation token, which is used to page through large
        result sets.   To get the next page of results, set this
        parameter to the value of   nextPageToken from the previous
        response.
        """
        self.variantSetId = kwargs.get(
            'variantSetId', None)
        """
        The VariantSet to search.
        """


class SearchCallSetsResponse(SearchResponse):
    """
    This is the response from POST /callsets/search expressed as JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchCallSetsResponse", "fields": [{"default": [], "doc": "",
"type": {"items": {"namespace": "org.ga4gh.models", "type": "record",
"name": "CallSet", "fields": [{"doc": "", "type": "string", "name":
"id"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "name"}, {"doc": "", "type": ["null", "string"], "name":
"sampleId"}, {"default": [], "doc": "", "type": {"items": "string",
"type": "array"}, "name": "variantSetIds"}, {"default": null, "doc":
"", "type": ["null", "long"], "name": "created"}, {"default": null,
"doc": "", "type": ["null", "long"], "name": "updated"}, {"default":
{}, "doc": "", "type": {"values": {"items": "string", "type":
"array"}, "type": "map"}, "name": "info"}], "doc": ""}, "type":
"array"}, "name": "callSets"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "nextPageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])
    _valueListName = "callSets"

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'callSets': CallSet,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'callSets': CallSet,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'callSets', 'nextPageToken'
    ]

    def __init__(self, **kwargs):
        self.callSets = kwargs.get(
            'callSets', [])
        """
        The list of matching call sets.
        """
        self.nextPageToken = kwargs.get(
            'nextPageToken', None)
        """
        The continuation token, which is used to page through large
        result sets.   Provide this value in a subsequent request to
        return the next page of   results. This field will be empty if
        there aren't any additional results.
        """


class SearchDatasetsRequest(SearchRequest):
    """
    This request maps to the body of POST /datasets/search as JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchDatasetsRequest", "fields": [{"default": null, "doc": "",
"type": ["null", "int"], "name": "pageSize"}, {"default": null, "doc":
"", "type": ["null", "string"], "name": "pageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'pageSize', 'pageToken'
    ]

    def __init__(self, **kwargs):
        self.pageSize = kwargs.get(
            'pageSize', None)
        """
        Specifies the maximum number of results to return in a single
        page.   If unspecified, a system default will be used.
        """
        self.pageToken = kwargs.get(
            'pageToken', None)
        """
        The continuation token, which is used to page through large
        result sets.   To get the next page of results, set this
        parameter to the value of   nextPageToken from the previous
        response.
        """


class SearchDatasetsResponse(SearchResponse):
    """
    This is the response from POST /datasets/search expressed as JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchDatasetsResponse", "fields": [{"default": [], "doc": "",
"type": {"items": {"namespace": "org.ga4gh.models", "type": "record",
"name": "Dataset", "fields": [{"doc": "", "type": "string", "name":
"id"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "description"}]}, "type": "array"}, "name": "datasets"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"nextPageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])
    _valueListName = "datasets"

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'datasets': Dataset,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'datasets': Dataset,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'datasets', 'nextPageToken'
    ]

    def __init__(self, **kwargs):
        self.datasets = kwargs.get(
            'datasets', [])
        """
        The list of datasets.
        """
        self.nextPageToken = kwargs.get(
            'nextPageToken', None)
        """
        The continuation token, which is used to page through large
        result sets.   Provide this value in a subsequent request to
        return the next page of   results. This field will be empty if
        there aren't any additional results.
        """


class SearchExperimentsRequest(SearchRequest):
    """
    This request maps to the body of POST /experiments/search as JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchExperimentsRequest", "fields": [{"default": null, "doc": "",
"type": ["null", "string"], "name": "name"}, {"default": null, "doc":
"", "type": ["null", "int"], "name": "pageSize"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "pageToken"}], "doc":
""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'name', 'pageSize', 'pageToken'
    ]

    def __init__(self, **kwargs):
        self.name = kwargs.get(
            'name', None)
        """
        Only return experiments with this name (case-sensitive, exact
        match).
        """
        self.pageSize = kwargs.get(
            'pageSize', None)
        """
        Specifies the maximum number of results to return in a single
        page.   If unspecified, a system default will be used.
        """
        self.pageToken = kwargs.get(
            'pageToken', None)
        """
        The continuation token, which is used to page through large
        result sets.   To get the next page of results, set this
        parameter to the value of   nextPageToken from the previous
        response.
        """


class SearchExperimentsResponse(SearchResponse):
    """
    This is the response from POST /experiments/search expressed as
    JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchExperimentsResponse", "fields": [{"default": [], "doc": "",
"type": {"items": {"namespace": "org.ga4gh.models", "type": "record",
"name": "Experiment", "fields": [{"doc": "", "type": "string", "name":
"id"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "name"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "description"}, {"doc": "", "type": "string",
"name": "recordCreateTime"}, {"doc": "", "type": "string", "name":
"recordUpdateTime"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "runTime"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "molecule"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "strategy"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "selection"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"library"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "libraryLayout"}, {"doc": "", "type": ["null", "string"],
"name": "instrumentModel"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "instrumentDataFile"}, {"doc": "", "type":
["null", "string"], "name": "sequencingCenter"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "platformUnit"},
{"default": {}, "doc": "", "type": {"values": {"items": "string",
"type": "array"}, "type": "map"}, "name": "info"}], "doc": ""},
"type": "array"}, "name": "experiments"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "nextPageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])
    _valueListName = "experiments"

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'experiments': Experiment,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'experiments': Experiment,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'experiments', 'nextPageToken'
    ]

    def __init__(self, **kwargs):
        self.experiments = kwargs.get(
            'experiments', [])
        """
        The list of matching experiments.
        """
        self.nextPageToken = kwargs.get(
            'nextPageToken', None)
        """
        The continuation token, which is used to page through large
        result sets.   Provide this value in a subsequent request to
        return the next page of   results. This field will be empty if
        there aren't any additional results.
        """


class SearchExpressionLevelRequest(SearchRequest):
    """
    This request maps to the body of 'POST /expressionlevel/search' as
    JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchExpressionLevelRequest", "fields": [{"default": null, "doc":
"", "type": ["null", "string"], "name": "expressionLevelId"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"featureGroupId"}, {"default": null, "doc": "", "type": "string",
"name": "rnaQuantificationId"}, {"default": null, "doc": "", "type":
["null", "float"], "name": "threshold"}, {"default": null, "doc": "",
"type": ["null", "int"], "name": "pageSize"}, {"default": null, "doc":
"", "type": ["null", "string"], "name": "pageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'expressionLevelId', 'featureGroupId', 'pageSize',
        'pageToken', 'rnaQuantificationId', 'threshold'
    ]

    def __init__(self, **kwargs):
        self.expressionLevelId = kwargs.get(
            'expressionLevelId', None)
        """
        If present, return matching Expression Level record.
        """
        self.featureGroupId = kwargs.get(
            'featureGroupId', None)
        """
        If present return only ExpressionLevel records which belong to
        this set.
        """
        self.pageSize = kwargs.get(
            'pageSize', None)
        """
        Specifies the maximum number of results to return in a single
        page.   If unspecified, a system default will be used.
        """
        self.pageToken = kwargs.get(
            'pageToken', None)
        """
        The continuation token, which is used to page through large
        result sets.   To get the next page of results, set this
        parameter to the value of   'nextPageToken' from the previous
        response.
        """
        self.rnaQuantificationId = kwargs.get(
            'rnaQuantificationId', None)
        """
        The rnaQuantification to restrict search to.
        """
        self.threshold = kwargs.get(
            'threshold', None)
        """
        If present returns ExpressionLevel records with expressions
        exceeding   this value.
        """


class SearchExpressionLevelResponse(SearchResponse):
    """
    This is the response from 'POST /expressionlevel/search' expressed
    as JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchExpressionLevelResponse", "fields": [{"default": [], "doc": "",
"type": {"items": {"namespace": "org.ga4gh.models", "type": "record",
"name": "ExpressionLevel", "fields": [{"doc": "", "type": "string",
"name": "id"}, {"doc": "", "type": "string", "name":
"featureGroupId"}, {"doc": "", "type": "string", "name":
"annotationId"}, {"doc": "", "type": "float", "name": "rawReadCount"},
{"default": null, "doc": "", "type": ["null", "float"], "name":
"expression"}, {"default": null, "doc": "", "type": ["null",
"boolean"], "name": "isNormalized"}, {"default": null, "doc": "",
"type": ["null", {"symbols": ["FPKM", "RPM"], "doc": "", "type":
"enum", "name": "ExpressionUnits"}], "name": "units"}, {"default":
null, "doc": "", "type": ["null", "float"], "name": "score"},
{"default": [], "doc": "", "type": {"items": "float", "type":
"array"}, "name": "confInterval"}], "doc": ""}, "type": "array"},
"name": "expressionLevel"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "nextPageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])
    _valueListName = "expressionLevel"

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'expressionLevel': ExpressionLevel,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'expressionLevel': ExpressionLevel,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'expressionLevel', 'nextPageToken'
    ]

    def __init__(self, **kwargs):
        self.expressionLevel = kwargs.get(
            'expressionLevel', [])
        """
        The line below is causing problems - naming or something wrong
        with the   import perhaps?
        """
        self.nextPageToken = kwargs.get(
            'nextPageToken', None)
        """
        The continuation token, which is used to page through large
        result sets.   To get the next page of results, set this
        parameter to the value of   'nextPageToken' from the previous
        response.
        """


class SearchFeatureGroupRequest(SearchRequest):
    """
    This request maps to the body of 'POST /featuregroup/search' as
    JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchFeatureGroupRequest", "fields": [{"default": null, "doc": "",
"type": "string", "name": "rnaQuantificationId"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "featureGroupId"},
{"default": null, "doc": "", "type": ["null", "int"], "name":
"pageSize"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "pageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'featureGroupId', 'pageSize', 'pageToken',
        'rnaQuantificationId'
    ]

    def __init__(self, **kwargs):
        self.featureGroupId = kwargs.get(
            'featureGroupId', None)
        """
        Feature Groups of interest.
        """
        self.pageSize = kwargs.get(
            'pageSize', None)
        """
        Specifies the maximum number of results to return in a single
        page.   If unspecified, a system default will be used.
        """
        self.pageToken = kwargs.get(
            'pageToken', None)
        """
        The continuation token, which is used to page through large
        result sets.   To get the next page of results, set this
        parameter to the value of   'nextPageToken' from the previous
        response.
        """
        self.rnaQuantificationId = kwargs.get(
            'rnaQuantificationId', None)
        """
        RNA Quantification to search.
        """


class SearchFeatureGroupResponse(SearchResponse):
    """
    This is the response from 'POST /featuregroup/search' expressed as
    JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchFeatureGroupResponse", "fields": [{"default": [], "doc": "",
"type": {"items": {"namespace": "org.ga4gh.models", "type": "record",
"name": "FeatureGroup", "fields": [{"doc": "", "type": "string",
"name": "id"}, {"doc": "", "type": "string", "name": "analysisId"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"name"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "description"}, {"default": null, "doc": "", "type": ["null",
"long"], "name": "created"}, {"default": null, "doc": "", "type":
["null", "long"], "name": "updated"}, {"default": {}, "doc": "",
"type": {"values": {"items": "string", "type": "array"}, "type":
"map"}, "name": "info"}], "doc": ""}, "type": "array"}, "name":
"featureGroup"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "nextPageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])
    _valueListName = "featureGroup"

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'featureGroup': FeatureGroup,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'featureGroup': FeatureGroup,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'featureGroup', 'nextPageToken'
    ]

    def __init__(self, **kwargs):
        self.featureGroup = kwargs.get(
            'featureGroup', [])
        """
        The list of matching feature groups.
        """
        self.nextPageToken = kwargs.get(
            'nextPageToken', None)
        """
        The continuation token, which is used to page through large
        result sets.   To get the next page of results, set this
        parameter to the value of   'nextPageToken' from the previous
        response.
        """


class SearchFeaturesRequest(SearchRequest):
    """
    This request maps to the body of POST /features/search as JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchFeaturesRequest", "fields": [{"doc": "", "type": ["null",
"string"], "name": "featureSetId"}, {"doc": "", "type": ["null",
"string"], "name": "parentId"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "referenceName"}, {"default": null, "doc":
"", "type": ["null", "string"], "name": "referenceId"}, {"doc": "",
"type": "long", "name": "start"}, {"doc": "", "type": "long", "name":
"end"}, {"default": [], "doc": "", "type": {"items": {"namespace":
"org.ga4gh.models", "type": "record", "name": "OntologyTerm",
"fields": [{"doc": "", "type": "string", "name": "ontologySource"},
{"doc": "", "type": "string", "name": "id"}, {"default": null, "doc":
"", "type": ["null", "string"], "name": "name"}], "doc": ""}, "type":
"array"}, "name": "features"}, {"default": null, "doc": "", "type":
["null", "int"], "name": "pageSize"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "pageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "end",
        "featureSetId",
        "parentId",
        "start",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'features': OntologyTerm,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'features': OntologyTerm,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'end', 'featureSetId', 'features', 'pageSize', 'pageToken',
        'parentId', 'referenceId', 'referenceName', 'start'
    ]

    def __init__(self, **kwargs):
        self.end = kwargs.get(
            'end', None)
        """
        Required. The end of the window (0-based, exclusive) for which
        overlapping     features should be returned.
        """
        self.featureSetId = kwargs.get(
            'featureSetId', None)
        """
        The annotation set to search within. Either featureSetId or
        parentId must be non-empty.
        """
        self.features = kwargs.get(
            'features', [])
        """
        If specified, this query matches only annotations which match
        one of the     provided feature types.
        """
        self.pageSize = kwargs.get(
            'pageSize', None)
        """
        Specifies the maximum number of results to return in a single
        page.     If unspecified, a system default will be used.
        """
        self.pageToken = kwargs.get(
            'pageToken', None)
        """
        The continuation token, which is used to page through large
        result sets.     To get the next page of results, set this
        parameter to the value of     nextPageToken from the previous
        response.
        """
        self.parentId = kwargs.get(
            'parentId', None)
        """
        Restricts the search to direct children of the given parent
        feature     ID. Either featureSetId or parentId must be non-
        empty.
        """
        self.referenceId = kwargs.get(
            'referenceId', None)
        """
        Only return feature on the reference with this ID. One of this
        field or     referenceName is required.
        """
        self.referenceName = kwargs.get(
            'referenceName', None)
        """
        Only return features with on the reference with this name.
        One of this     field or referenceId is required.  (case-
        sensitive, exact match)
        """
        self.start = kwargs.get(
            'start', None)
        """
        Required. The beginning of the window (0-based, inclusive) for
        which     overlapping features should be returned.  Genomic
        positions are     non-negative integers less than reference
        length.  Requests spanning the     join of circular genomes
        are represented as two requests one on each side     of the
        join (position 0).
        """


class SearchFeaturesResponse(SearchResponse):
    """
    This is the response from POST /features/search expressed as JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchFeaturesResponse", "fields": [{"default": [], "doc": "",
"type": {"items": {"namespace": "org.ga4gh.models", "type": "record",
"name": "Feature", "fields": [{"doc": "", "type": "string", "name":
"id"}, {"doc": "", "type": {"items": "string", "type": "array"},
"name": "parentIds"}, {"doc": "", "type": "string", "name":
"featureSetId"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "referenceName"}, {"default": null, "doc": "",
"type": ["null", "long"], "name": "start"}, {"default": null, "doc":
"", "type": ["null", "long"], "name": "end"}, {"doc": "", "type":
{"doc": "", "type": "record", "name": "OntologyTerm", "fields":
[{"doc": "", "type": "string", "name": "ontologySource"}, {"doc": "",
"type": "string", "name": "id"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "name"}]}, "name": "featureType"}, {"doc":
"", "type": {"doc": "", "type": "record", "name": "Attributes",
"fields": [{"default": {}, "type": {"values": {"items": ["string",
{"doc": "", "type": "record", "name": "ExternalIdentifier", "fields":
[{"doc": "", "type": "string", "name": "database"}, {"doc": "",
"type": "string", "name": "identifier"}, {"doc": "", "type": "string",
"name": "version"}]}, "OntologyTerm"], "type": "array"}, "type":
"map"}, "name": "vals"}]}, "name": "attributes"}], "doc": ""}, "type":
"array"}, "name": "features"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "nextPageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])
    _valueListName = "features"

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'features': Feature,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'features': Feature,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'features', 'nextPageToken'
    ]

    def __init__(self, **kwargs):
        self.features = kwargs.get(
            'features', [])
        """
        The list of matching annotations, sorted by start position.
        Annotations which     share a start position are returned in a
        deterministic order.
        """
        self.nextPageToken = kwargs.get(
            'nextPageToken', None)
        """
        The continuation token, which is used to page through large
        result sets.     Provide this value in a subsequent request to
        return the next page of     results. This field will be empty
        if there aren't any additional results.
        """


class SearchIndividualGroupsRequest(SearchRequest):
    """
    This request maps to the body of POST /individualgroups/search as
    JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchIndividualGroupsRequest", "fields": [{"default": null, "doc":
"", "type": ["null", "string"], "name": "name"}, {"default": null,
"doc": "", "type": ["null", "int"], "name": "pageSize"}, {"default":
null, "doc": "", "type": ["null", "string"], "name": "pageToken"}],
"doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'name', 'pageSize', 'pageToken'
    ]

    def __init__(self, **kwargs):
        self.name = kwargs.get(
            'name', None)
        """
        Only return individual groups with this name (case-sensitive,
        exact match).
        """
        self.pageSize = kwargs.get(
            'pageSize', None)
        """
        Specifies the maximum number of results to return in a single
        page.   If unspecified, a system default will be used.
        """
        self.pageToken = kwargs.get(
            'pageToken', None)
        """
        The continuation token, which is used to page through large
        result sets.   To get the next page of results, set this
        parameter to the value of   nextPageToken from the previous
        response.
        """


class SearchIndividualGroupsResponse(SearchResponse):
    """
    This is the response from POST /individualgroups/search expressed
    as JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchIndividualGroupsResponse", "fields": [{"default": [], "doc":
"", "type": {"items": {"namespace": "org.ga4gh.models", "type":
"record", "name": "IndividualGroup", "fields": [{"doc": "", "type":
"string", "name": "id"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "name"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "description"}, {"doc": "", "type":
"string", "name": "recordCreateTime"}, {"doc": "", "type": "string",
"name": "recordUpdateTime"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "type"}, {"default": {}, "doc": "",
"type": {"values": {"items": "string", "type": "array"}, "type":
"map"}, "name": "info"}], "doc": ""}, "type": "array"}, "name":
"individualGroups"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "nextPageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])
    _valueListName = "individualGroups"

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'individualGroups': IndividualGroup,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'individualGroups': IndividualGroup,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'individualGroups', 'nextPageToken'
    ]

    def __init__(self, **kwargs):
        self.individualGroups = kwargs.get(
            'individualGroups', [])
        """
        The list of matching individual groups.
        """
        self.nextPageToken = kwargs.get(
            'nextPageToken', None)
        """
        The continuation token, which is used to page through large
        result sets.   Provide this value in a subsequent request to
        return the next page of   results. This field will be empty if
        there aren't any additional results.
        """


class SearchIndividualsRequest(SearchRequest):
    """
    This request maps to the body of POST /individuals/search as JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchIndividualsRequest", "fields": [{"doc": "", "type": "string",
"name": "groupId"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "name"}, {"default": null, "doc": "", "type":
["null", "int"], "name": "pageSize"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "pageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "groupId",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'groupId', 'name', 'pageSize', 'pageToken'
    ]

    def __init__(self, **kwargs):
        self.groupId = kwargs.get(
            'groupId', None)
        """
        The Group to search.
        """
        self.name = kwargs.get(
            'name', None)
        """
        Only return individuals with this name (case-sensitive, exact
        match).
        """
        self.pageSize = kwargs.get(
            'pageSize', None)
        """
        Specifies the maximum number of results to return in a single
        page.   If unspecified, a system default will be used.
        """
        self.pageToken = kwargs.get(
            'pageToken', None)
        """
        The continuation token, which is used to page through large
        result sets.   To get the next page of results, set this
        parameter to the value of   nextPageToken from the previous
        response.
        """


class SearchIndividualsResponse(SearchResponse):
    """
    This is the response from POST /individuals/search expressed as
    JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchIndividualsResponse", "fields": [{"default": [], "doc": "",
"type": {"items": {"namespace": "org.ga4gh.models", "type": "record",
"name": "Individual", "fields": [{"doc": "", "type": "string", "name":
"id"}, {"default": [], "doc": "", "type": {"items": "string", "type":
"array"}, "name": "groupIds"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "name"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "description"}, {"doc": "",
"type": "string", "name": "recordCreateTime"}, {"doc": "", "type":
"string", "name": "recordUpdateTime"}, {"default": null, "doc": "",
"type": ["null", {"doc": "", "type": "record", "name": "OntologyTerm",
"fields": [{"default": null, "doc": "", "type": ["null", "string"],
"name": "ontologySourceName"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "ontologySourceID"}, {"default": null,
"doc": "", "type": ["null", "string"], "name":
"ontologySourceVersion"}]}], "name": "species"}, {"default": null,
"doc": "", "type": ["null", "OntologyTerm"], "name": "sex"},
{"default": null, "doc": "", "type": ["null", "OntologyTerm"], "name":
"developmentalStage"}, {"default": null, "doc": "", "type": ["null",
"long"], "name": "dateOfBirth"}, {"default": [], "doc": "", "type":
{"items": "OntologyTerm", "type": "array"}, "name": "diseases"},
{"default": [], "doc": "", "type": {"items": "OntologyTerm", "type":
"array"}, "name": "phenotypes"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "stagingSystem"}, {"default": null, "doc":
"", "type": ["null", "string"], "name": "clinicalTreatment"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"strain"}, {"default": {}, "doc": "", "type": {"values": {"items":
"string", "type": "array"}, "type": "map"}, "name": "info"}], "doc":
""}, "type": "array"}, "name": "individuals"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "nextPageToken"}],
"doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])
    _valueListName = "individuals"

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'individuals': Individual,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'individuals': Individual,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'individuals', 'nextPageToken'
    ]

    def __init__(self, **kwargs):
        self.individuals = kwargs.get(
            'individuals', [])
        """
        The list of matching individuals.
        """
        self.nextPageToken = kwargs.get(
            'nextPageToken', None)
        """
        The continuation token, which is used to page through large
        result sets.   Provide this value in a subsequent request to
        return the next page of   results. This field will be empty if
        there aren't any additional results.
        """


class SearchJoinsRequest(SearchRequest):
    """
    This request maps to the body of POST /joins/search as JSON.
    Specifies a number of filters, all of which must be satisfied by
    each result returned.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchJoinsRequest", "fields": [{"default": null, "doc": "", "type":
["null", "string"], "name": "referenceSetId"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "variantSetId"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"sequenceId"}, {"default": null, "doc": "", "type": ["null", "long"],
"name": "start"}, {"default": null, "doc": "", "type": ["null",
"long"], "name": "length"}, {"default": null, "doc": "", "type":
["null", {"symbols": ["NEG_STRAND", "POS_STRAND"], "namespace":
"org.ga4gh.models", "type": "enum", "name": "Strand", "doc": ""}],
"name": "strand"}, {"default": null, "doc": "", "type": ["null",
"int"], "name": "pageSize"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "pageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'length', 'pageSize', 'pageToken', 'referenceSetId',
        'sequenceId', 'start', 'strand', 'variantSetId'
    ]

    def __init__(self, **kwargs):
        self.length = kwargs.get(
            'length', None)
        """
        If not null, return only Joins with at least one Side on the
        sequence   specified by sequenceId in the interval [start,
        start + length).
        """
        self.pageSize = kwargs.get(
            'pageSize', None)
        """
        Specifies the maximum number of results to return in a single
        page.   If unspecified, a system default will be used.
        """
        self.pageToken = kwargs.get(
            'pageToken', None)
        """
        The continuation token, which is used to page through large
        result sets.   To get the next page of results, set this
        parameter to the value of   nextPageToken from the previous
        response.
        """
        self.referenceSetId = kwargs.get(
            'referenceSetId', None)
        """
        If not null, return only Joins which belong to this reference
        set, or any   included ReferenceSets.    If null, variantSetId
        must not be null.
        """
        self.sequenceId = kwargs.get(
            'sequenceId', None)
        """
        If not null, return only Joins with at least one Side on this
        sequence.   sequences.    If null, start, length, and strand
        must be null.
        """
        self.start = kwargs.get(
            'start', None)
        """
        If not null, return only Joins with at least one Side at this
        index or   later in the Sequence specified by sequenceId.
        If null, length must be null.
        """
        self.strand = kwargs.get(
            'strand', None)
        """
        If not null, return only Joins which join onto this strand of
        the Sequence   specified by sequenceId.
        """
        self.variantSetId = kwargs.get(
            'variantSetId', None)
        """
        If not null, return only Joins which belong to this variant
        set.    If null, referenceSetId must not be null.
        """


class SearchJoinsResponse(SearchResponse):
    """
    This is the response from POST /joins/search expressed as JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchJoinsResponse", "fields": [{"default": [], "doc": "", "type":
{"items": {"namespace": "org.ga4gh.models", "type": "record", "name":
"Join", "fields": [{"doc": "", "type": {"doc": "", "type": "record",
"name": "Side", "fields": [{"doc": "", "type": {"doc": "", "type":
"record", "name": "Position", "fields": [{"default": null, "doc": "",
"type": ["null", "string"], "name": "sequenceId"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "referenceName"},
{"doc": "", "type": "long", "name": "position"}]}, "name": "base"},
{"doc": "", "type": {"symbols": ["NEG_STRAND", "POS_STRAND"], "doc":
"", "type": "enum", "name": "Strand"}, "name": "strand"}]}, "name":
"side1"}, {"doc": "", "type": "Side", "name": "side2"}], "doc": ""},
"type": "array"}, "name": "joins"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "nextPageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])
    _valueListName = "joins"

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'joins': Join,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'joins': Join,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'joins', 'nextPageToken'
    ]

    def __init__(self, **kwargs):
        self.joins = kwargs.get(
            'joins', [])
        """
        The list of matching joins.
        """
        self.nextPageToken = kwargs.get(
            'nextPageToken', None)
        """
        The continuation token, which is used to page through large
        result sets.   Provide this value in a subsequent request to
        return the next page of   results. This field will be empty if
        there aren't any additional results.
        """


class SearchReadGroupSetsRequest(SearchRequest):
    """
    This request maps to the body of POST /readgroupsets/search as
    JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchReadGroupSetsRequest", "fields": [{"doc": "", "type": "string",
"name": "datasetId"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "name"}, {"default": null, "doc": "", "type":
["null", "int"], "name": "pageSize"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "pageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "datasetId",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'datasetId', 'name', 'pageSize', 'pageToken'
    ]

    def __init__(self, **kwargs):
        self.datasetId = kwargs.get(
            'datasetId', None)
        """
        The dataset to search.
        """
        self.name = kwargs.get(
            'name', None)
        """
        Only return read group sets with this name (case-sensitive,
        exact match).
        """
        self.pageSize = kwargs.get(
            'pageSize', None)
        """
        Specifies the maximum number of results to return in a single
        page.   If unspecified, a system default will be used.
        """
        self.pageToken = kwargs.get(
            'pageToken', None)
        """
        The continuation token, which is used to page through large
        result sets.   To get the next page of results, set this
        parameter to the value of   nextPageToken from the previous
        response.
        """


class SearchReadGroupSetsResponse(SearchResponse):
    """
    This is the response from POST /readgroupsets/search expressed as
    JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchReadGroupSetsResponse", "fields": [{"default": [], "doc": "",
"type": {"items": {"namespace": "org.ga4gh.models", "type": "record",
"name": "ReadGroupSet", "fields": [{"doc": "", "type": "string",
"name": "id"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "datasetId"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "name"}, {"default": null, "doc": "",
"type": ["null", {"fields": [{"default": null, "doc": "", "type":
["null", "long"], "name": "alignedReadCount"}, {"default": null,
"doc": "", "type": ["null", "long"], "name": "unalignedReadCount"},
{"default": null, "doc": "", "type": ["null", "long"], "name":
"baseCount"}], "type": "record", "name": "ReadStats"}], "name":
"stats"}, {"default": [], "doc": "", "type": {"items": {"fields":
[{"doc": "", "type": "string", "name": "id"}, {"default": null, "doc":
"", "type": ["null", "string"], "name": "datasetId"}, {"default":
null, "doc": "", "type": ["null", "string"], "name": "name"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"description"}, {"doc": "", "type": ["null", "string"], "name":
"sampleId"}, {"doc": "", "type": ["null", {"doc": "", "type":
"record", "name": "Experiment", "fields": [{"doc": "", "type":
"string", "name": "id"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "name"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "description"}, {"doc": "", "type":
"string", "name": "recordCreateTime"}, {"doc": "", "type": "string",
"name": "recordUpdateTime"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "runTime"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "molecule"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "strategy"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"selection"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "library"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "libraryLayout"}, {"doc": "", "type": ["null",
"string"], "name": "instrumentModel"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "instrumentDataFile"}, {"doc": "",
"type": ["null", "string"], "name": "sequencingCenter"}, {"default":
null, "doc": "", "type": ["null", "string"], "name": "platformUnit"},
{"default": {}, "doc": "", "type": {"values": {"items": "string",
"type": "array"}, "type": "map"}, "name": "info"}]}], "name":
"experiment"}, {"default": null, "doc": "", "type": ["null", "int"],
"name": "predictedInsertSize"}, {"default": null, "doc": "", "type":
["null", "long"], "name": "created"}, {"default": null, "doc": "",
"type": ["null", "long"], "name": "updated"}, {"default": null, "doc":
"", "type": ["null", "ReadStats"], "name": "stats"}, {"default": [],
"doc": "", "type": {"items": {"fields": [{"default": null, "doc": "",
"type": ["null", "string"], "name": "commandLine"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "id"}, {"default":
null, "doc": "", "type": ["null", "string"], "name": "name"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"prevProgramId"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "version"}], "type": "record", "name": "Program"},
"type": "array"}, "name": "programs"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "referenceSetId"}, {"default": {},
"doc": "", "type": {"values": {"items": "string", "type": "array"},
"type": "map"}, "name": "info"}], "type": "record", "name":
"ReadGroup"}, "type": "array"}, "name": "readGroups"}]}, "type":
"array"}, "name": "readGroupSets"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "nextPageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])
    _valueListName = "readGroupSets"

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'readGroupSets': ReadGroupSet,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'readGroupSets': ReadGroupSet,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'nextPageToken', 'readGroupSets'
    ]

    def __init__(self, **kwargs):
        self.nextPageToken = kwargs.get(
            'nextPageToken', None)
        """
        The continuation token, which is used to page through large
        result sets.   Provide this value in a subsequent request to
        return the next page of   results. This field will be empty if
        there aren't any additional results.
        """
        self.readGroupSets = kwargs.get(
            'readGroupSets', [])
        """
        The list of matching read group sets.
        """


class SearchReadsRequest(SearchRequest):
    """
    This request maps to the body of POST /reads/search as JSON.  If a
    reference is specified, all queried ReadGroups must be aligned to
    ReferenceSets containing that same Reference. If no reference is
    specified, all ReadGroups must be aligned to the same
    ReferenceSet.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchReadsRequest", "fields": [{"doc": "", "type": {"items":
"string", "type": "array"}, "name": "readGroupIds"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "referenceId"},
{"default": null, "doc": "", "type": ["null", "long"], "name":
"start"}, {"default": null, "doc": "", "type": ["null", "long"],
"name": "end"}, {"default": null, "doc": "", "type": ["null", "int"],
"name": "pageSize"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "pageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "readGroupIds",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'end', 'pageSize', 'pageToken', 'readGroupIds', 'referenceId',
        'start'
    ]

    def __init__(self, **kwargs):
        self.end = kwargs.get(
            'end', None)
        """
        The end position (0-based, exclusive) of this query.   If a
        reference is specified, this defaults to the   reference's
        length.
        """
        self.pageSize = kwargs.get(
            'pageSize', None)
        """
        Specifies the maximum number of results to return in a single
        page.   If unspecified, a system default will be used.
        """
        self.pageToken = kwargs.get(
            'pageToken', None)
        """
        The continuation token, which is used to page through large
        result sets.   To get the next page of results, set this
        parameter to the value of   nextPageToken from the previous
        response.
        """
        self.readGroupIds = kwargs.get(
            'readGroupIds', None)
        """
        The ReadGroups to search. At least one readGroupId must be
        specified.
        """
        self.referenceId = kwargs.get(
            'referenceId', None)
        """
        The reference to query. Leaving blank returns results from all
        references, including unmapped reads - this could be very
        large.
        """
        self.start = kwargs.get(
            'start', None)
        """
        The start position (0-based) of this query.   If a reference
        is specified, this defaults to 0.   Genomic positions are non-
        negative integers less than reference length.   Requests
        spanning the join of circular genomes are represented as   two
        requests one on each side of the join (position 0).
        """


class SearchReadsResponse(SearchResponse):
    """
    This is the response from POST /reads/search expressed as JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchReadsResponse", "fields": [{"default": [], "doc": "", "type":
{"items": {"namespace": "org.ga4gh.models", "type": "record", "name":
"ReadAlignment", "fields": [{"doc": "", "type": ["null", "string"],
"name": "id"}, {"doc": "", "type": "string", "name": "readGroupId"},
{"doc": "", "type": "string", "name": "fragmentId"}, {"doc": "",
"type": "string", "name": "fragmentName"}, {"default": null, "doc":
"", "type": ["null", "boolean"], "name": "properPlacement"},
{"default": null, "doc": "", "type": ["null", "boolean"], "name":
"duplicateFragment"}, {"default": null, "doc": "", "type": ["null",
"int"], "name": "numberReads"}, {"default": null, "doc": "", "type":
["null", "int"], "name": "fragmentLength"}, {"default": null, "doc":
"", "type": ["null", "int"], "name": "readNumber"}, {"default": null,
"doc": "", "type": ["null", "boolean"], "name":
"failedVendorQualityChecks"}, {"default": null, "doc": "", "type":
["null", {"doc": "", "type": "record", "name": "LinearAlignment",
"fields": [{"doc": "", "type": {"doc": "", "type": "record", "name":
"Side", "fields": [{"doc": "", "type": {"doc": "", "type": "record",
"name": "Position", "fields": [{"default": null, "doc": "", "type":
["null", "string"], "name": "sequenceId"}, {"default": null, "doc":
"", "type": ["null", "string"], "name": "referenceName"}, {"doc": "",
"type": "long", "name": "position"}]}, "name": "base"}, {"doc": "",
"type": {"symbols": ["NEG_STRAND", "POS_STRAND"], "doc": "", "type":
"enum", "name": "Strand"}, "name": "strand"}]}, "name": "position"},
{"default": null, "doc": "", "type": ["null", "int"], "name":
"mappingQuality"}, {"default": [], "doc": "", "type": {"items":
{"doc": "", "type": "record", "name": "CigarUnit", "fields": [{"doc":
"", "type": {"symbols": ["ALIGNMENT_MATCH", "INSERT", "DELETE",
"SKIP", "CLIP_SOFT", "CLIP_HARD", "PAD", "SEQUENCE_MATCH",
"SEQUENCE_MISMATCH"], "doc": "", "type": "enum", "name":
"CigarOperation"}, "name": "operation"}, {"doc": "", "type": "long",
"name": "operationLength"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "referenceSequence"}]}, "type": "array"},
"name": "cigar"}]}], "name": "alignment"}, {"default": null, "doc":
"", "type": ["null", {"doc": "", "type": "record", "name":
"GraphAlignment", "fields": [{"doc": "", "type": {"doc": "", "type":
"record", "name": "Path", "fields": [{"default": [], "doc": "",
"type": {"items": {"doc": "", "type": "record", "name": "Segment",
"fields": [{"doc": "", "type": "Side", "name": "start"}, {"doc": "",
"type": "long", "name": "length"}]}, "type": "array"}, "name":
"segments"}]}, "name": "path"}, {"default": null, "doc": "", "type":
["null", "int"], "name": "mappingQuality"}, {"default": [], "doc": "",
"type": {"items": "CigarUnit", "type": "array"}, "name": "cigar"}]}],
"name": "graphAlignment"}, {"default": null, "doc": "", "type":
["null", "boolean"], "name": "secondaryAlignment"}, {"default": null,
"doc": "", "type": ["null", "boolean"], "name":
"supplementaryAlignment"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "alignedSequence"}, {"default": [], "doc":
"", "type": {"items": "int", "type": "array"}, "name":
"alignedQuality"}, {"default": null, "doc": "", "type": ["null",
"Side"], "name": "nextMatePosition"}, {"default": {}, "doc": "",
"type": {"values": {"items": "string", "type": "array"}, "type":
"map"}, "name": "info"}], "doc": ""}, "type": "array"}, "name":
"alignments"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "nextPageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])
    _valueListName = "alignments"

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'alignments': ReadAlignment,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'alignments': ReadAlignment,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'alignments', 'nextPageToken'
    ]

    def __init__(self, **kwargs):
        self.alignments = kwargs.get(
            'alignments', [])
        """
        The list of matching alignment records, sorted by position.
        Unmapped reads, which have no position, are returned last.
        """
        self.nextPageToken = kwargs.get(
            'nextPageToken', None)
        """
        The continuation token, which is used to page through large
        result sets.   Provide this value in a subsequent request to
        return the next page of   results. This field will be empty if
        there aren't any additional results.
        """


class SearchReferenceSetsRequest(SearchRequest):
    """
    This request maps to the body of POST /referencesets/search as
    JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchReferenceSetsRequest", "fields": [{"default": [], "doc": "",
"type": {"items": "string", "type": "array"}, "name": "md5checksums"},
{"default": [], "doc": "", "type": {"items": "string", "type":
"array"}, "name": "accessions"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "assemblyId"}, {"default": null, "doc":
"", "type": ["null", "int"], "name": "pageSize"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "pageToken"}], "doc":
""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'accessions', 'assemblyId', 'md5checksums', 'pageSize',
        'pageToken'
    ]

    def __init__(self, **kwargs):
        self.accessions = kwargs.get(
            'accessions', [])
        """
        If nonempty, return reference sets for which the accession
        matches this string. Best to give a version number (e.g.
        GCF_000001405.26).   If only the main accession number is
        given then all records with   that main accession will be
        returned, whichever version.   Note that different versions
        will have different sequences.
        """
        self.assemblyId = kwargs.get(
            'assemblyId', None)
        """
        If not null, return reference sets for which the assemblyId
        matches this string (case-sensitive, exact match).
        """
        self.md5checksums = kwargs.get(
            'md5checksums', [])
        """
        If nonempty, return the reference sets which match any of the
        given   md5checksums. See ReferenceSet::md5checksum for
        details.
        """
        self.pageSize = kwargs.get(
            'pageSize', None)
        """
        Specifies the maximum number of results to return in a single
        page.   If unspecified, a system default will be used.
        """
        self.pageToken = kwargs.get(
            'pageToken', None)
        """
        The continuation token, which is used to page through large
        result sets.   To get the next page of results, set this
        parameter to the value of   nextPageToken from the previous
        response.
        """


class SearchReferenceSetsResponse(SearchResponse):
    """
    This is the response from POST /referencesets/search expressed as
    JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchReferenceSetsResponse", "fields": [{"default": [], "doc": "",
"type": {"items": {"namespace": "org.ga4gh.models", "type": "record",
"name": "ReferenceSet", "fields": [{"doc": "", "type": "string",
"name": "id"}, {"default": null, "doc": "", "type": ["null", {"items":
"string", "type": "array"}], "name": "referenceIds"}, {"default": [],
"doc": "", "type": {"items": "string", "type": "array"}, "name":
"includedReferenceSets"}, {"doc": "", "type": "string", "name":
"md5checksum"}, {"default": null, "doc": "", "type": ["null", "int"],
"name": "ncbiTaxonId"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "description"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "assemblyId"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "sourceURI"}, {"doc":
"", "type": {"items": "string", "type": "array"}, "name":
"sourceAccessions"}, {"default": false, "doc": "", "type": "boolean",
"name": "isDerived"}], "doc": ""}, "type": "array"}, "name":
"referenceSets"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "nextPageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])
    _valueListName = "referenceSets"

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'referenceSets': ReferenceSet,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'referenceSets': ReferenceSet,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'nextPageToken', 'referenceSets'
    ]

    def __init__(self, **kwargs):
        self.nextPageToken = kwargs.get(
            'nextPageToken', None)
        """
        The continuation token, which is used to page through large
        result sets.   Provide this value in a subsequent request to
        return the next page of   results. This field will be empty if
        there aren't any additional results.
        """
        self.referenceSets = kwargs.get(
            'referenceSets', [])
        """
        The list of matching reference sets.
        """


class SearchReferencesRequest(SearchRequest):
    """
    This request maps to the body of POST /references/search as JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchReferencesRequest", "fields": [{"default": null, "doc": "",
"type": ["null", "string"], "name": "referenceSetId"}, {"default": [],
"doc": "", "type": {"items": "string", "type": "array"}, "name":
"sequenceIds"}, {"default": [], "doc": "", "type": {"items": "string",
"type": "array"}, "name": "md5checksums"}, {"default": [], "doc": "",
"type": {"items": "string", "type": "array"}, "name": "accessions"},
{"default": [], "doc": "", "type": {"items": "string", "type":
"array"}, "name": "referenceNames"}, {"default": null, "doc": "",
"type": ["null", "int"], "name": "pageSize"}, {"default": null, "doc":
"", "type": ["null", "string"], "name": "pageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'accessions', 'md5checksums', 'pageSize', 'pageToken',
        'referenceNames', 'referenceSetId', 'sequenceIds'
    ]

    def __init__(self, **kwargs):
        self.accessions = kwargs.get(
            'accessions', [])
        """
        If nonempty, return references for which the accession
        matches this string. Best to give a version number e.g.
        GCF_000001405.26.   If only the main accession number is given
        then all records with   that main accession will be returned,
        whichever version.   Note that different versions will have
        different sequences.
        """
        self.md5checksums = kwargs.get(
            'md5checksums', [])
        """
        If nonempty, return references which match any of the given
        md5checksums.   See Reference::md5checksum for details.
        """
        self.pageSize = kwargs.get(
            'pageSize', None)
        """
        Specifies the maximum number of results to return in a single
        page.   If unspecified, a system default will be used.
        """
        self.pageToken = kwargs.get(
            'pageToken', None)
        """
        The continuation token, which is used to page through large
        result sets.   To get the next page of results, set this
        parameter to the value of   nextPageToken from the previous
        response.
        """
        self.referenceNames = kwargs.get(
            'referenceNames', [])
        """
        If nonempty, return references that have one of the specified
        names. The name   specified must match the reference's name
        exactly, and is case sensitive.
        """
        self.referenceSetId = kwargs.get(
            'referenceSetId', None)
        """
        If not null, return only references which belong to this
        reference set.
        """
        self.sequenceIds = kwargs.get(
            'sequenceIds', [])
        """
        If nonempty, return only References on Sequences with IDs in
        the list.
        """


class SearchReferencesResponse(SearchResponse):
    """
    This is the response from POST /references/search expressed as
    JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchReferencesResponse", "fields": [{"default": [], "doc": "",
"type": {"items": {"namespace": "org.ga4gh.models", "type": "record",
"name": "Reference", "fields": [{"doc": "", "type": "string", "name":
"id"}, {"doc": "", "type": "string", "name": "sequenceId"}, {"doc":
"", "type": "long", "name": "start"}, {"doc": "", "type": "long",
"name": "length"}, {"doc": "", "type": "string", "name":
"md5checksum"}, {"doc": "", "type": "string", "name": "name"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"sourceURI"}, {"doc": "", "type": {"items": "string", "type":
"array"}, "name": "sourceAccessions"}, {"default": false, "doc": "",
"type": "boolean", "name": "isDerived"}, {"default": null, "doc": "",
"type": ["null", "float"], "name": "sourceDivergence"}, {"default":
null, "doc": "", "type": ["null", "int"], "name": "ncbiTaxonId"},
{"default": true, "doc": "", "type": "boolean", "name": "isPrimary"}],
"doc": ""}, "type": "array"}, "name": "references"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "nextPageToken"}],
"doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])
    _valueListName = "references"

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'references': Reference,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'references': Reference,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'nextPageToken', 'references'
    ]

    def __init__(self, **kwargs):
        self.nextPageToken = kwargs.get(
            'nextPageToken', None)
        """
        The continuation token, which is used to page through large
        result sets.   Provide this value in a subsequent request to
        return the next page of   results. This field will be empty if
        there aren't any additional results.
        """
        self.references = kwargs.get(
            'references', [])
        """
        The list of matching references.
        """


class SearchRnaQuantificationRequest(SearchRequest):
    """
    This request maps to the body of 'POST /rnaquantification/search'
    as JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchRnaQuantificationRequest", "fields": [{"default": null, "doc":
"", "type": ["null", "string"], "name": "rnaQuantificationId"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"datasetId"}, {"default": null, "doc": "", "type": ["null", "int"],
"name": "pageSize"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "pageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'datasetId', 'pageSize', 'pageToken', 'rnaQuantificationId'
    ]

    def __init__(self, **kwargs):
        self.datasetId = kwargs.get(
            'datasetId', None)
        """
        If present, return only Rna Quantifications which belong to
        this set.
        """
        self.pageSize = kwargs.get(
            'pageSize', None)
        """
        Specifies the maximum number of results to return in a single
        page.   If unspecified, a system default will be used.
        """
        self.pageToken = kwargs.get(
            'pageToken', None)
        """
        The continuation token, which is used to page through large
        result sets.   To get the next page of results, set this
        parameter to the value of   'nextPageToken' from the previous
        response.
        """
        self.rnaQuantificationId = kwargs.get(
            'rnaQuantificationId', None)
        """
        If present, return only Rna Quantifications which belong to
        this set.
        """


class SearchRnaQuantificationResponse(SearchResponse):
    """
    This is the response from 'POST /rnaquantification/search'
    expressed as JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchRnaQuantificationResponse", "fields": [{"default": [], "doc":
"", "type": {"items": {"namespace": "org.ga4gh.models", "type":
"record", "name": "RnaQuantification", "fields": [{"doc": "", "type":
"string", "name": "id"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "name"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "description"}, {"doc": "", "type":
"string", "name": "readGroupId"}, {"default": [], "doc": "", "type":
{"items": "string", "type": "array"}, "name": "programIds"},
{"default": [], "doc": "", "type": {"items": "string", "type":
"array"}, "name": "annotationIds"}], "doc": ""}, "type": "array"},
"name": "rnaQuantification"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "nextPageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])
    _valueListName = "rnaQuantification"

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'rnaQuantification': RnaQuantification,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'rnaQuantification': RnaQuantification,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'nextPageToken', 'rnaQuantification'
    ]

    def __init__(self, **kwargs):
        self.nextPageToken = kwargs.get(
            'nextPageToken', None)
        """
        The continuation token, which is used to page through large
        result sets.   To get the next page of results, set this
        parameter to the value of   'nextPageToken' from the previous
        response.
        """
        self.rnaQuantification = kwargs.get(
            'rnaQuantification', [])
        """
        The list of matching quantifications.
        """


class SearchSamplesRequest(SearchRequest):
    """
    This request maps to the body of POST /samples/search as JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchSamplesRequest", "fields": [{"doc": "", "type": "string",
"name": "individualId"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "name"}, {"default": null, "doc": "", "type":
["null", "int"], "name": "pageSize"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "pageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "individualId",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'individualId', 'name', 'pageSize', 'pageToken'
    ]

    def __init__(self, **kwargs):
        self.individualId = kwargs.get(
            'individualId', None)
        """
        The Individual to search.
        """
        self.name = kwargs.get(
            'name', None)
        """
        Only return samples with this name (case-sensitive, exact
        match).
        """
        self.pageSize = kwargs.get(
            'pageSize', None)
        """
        Specifies the maximum number of results to return in a single
        page.   If unspecified, a system default will be used.
        """
        self.pageToken = kwargs.get(
            'pageToken', None)
        """
        The continuation token, which is used to page through large
        result sets.   To get the next page of results, set this
        parameter to the value of   nextPageToken from the previous
        response.
        """


class SearchSamplesResponse(SearchResponse):
    """
    This is the response from POST /samples/search expressed as JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchSamplesResponse", "fields": [{"default": [], "doc": "", "type":
{"items": {"namespace": "org.ga4gh.models", "type": "record", "name":
"Sample", "fields": [{"doc": "", "type": "string", "name": "id"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"individualId"}, {"default": [], "doc": "", "type": {"items":
"string", "type": "array"}, "name": "accessions"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "name"}, {"default":
null, "doc": "", "type": ["null", "string"], "name": "description"},
{"doc": "", "type": "string", "name": "recordCreateTime"}, {"doc": "",
"type": "string", "name": "recordUpdateTime"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "samplingDate"},
{"default": null, "doc": "", "type": ["null", "long"], "name":
"ageAtSampling"}, {"default": null, "doc": "", "type": ["null",
{"doc": "", "type": "record", "name": "OntologyTerm", "fields":
[{"default": null, "doc": "", "type": ["null", "string"], "name":
"ontologySourceName"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "ontologySourceID"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "ontologySourceVersion"}]}],
"name": "cellType"}, {"default": null, "doc": "", "type": ["null",
"OntologyTerm"], "name": "cellLine"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "geocode"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "sampleType"},
{"default": null, "doc": "", "type": ["null", "OntologyTerm"], "name":
"organismPart"}, {"default": {}, "doc": "", "type": {"values":
{"items": "string", "type": "array"}, "type": "map"}, "name":
"info"}], "doc": ""}, "type": "array"}, "name": "samples"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"nextPageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])
    _valueListName = "samples"

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'samples': Sample,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'samples': Sample,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'nextPageToken', 'samples'
    ]

    def __init__(self, **kwargs):
        self.nextPageToken = kwargs.get(
            'nextPageToken', None)
        """
        The continuation token, which is used to page through large
        result sets.   Provide this value in a subsequent request to
        return the next page of   results. This field will be empty if
        there aren't any additional results.
        """
        self.samples = kwargs.get(
            'samples', [])
        """
        The list of matching samples.
        """


class SearchSequencesRequest(SearchRequest):
    """
    This request maps to the body of POST /sequences/search as JSON.
    Specifies a number of filters, all of which must be satisfied by
    each result returned.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchSequencesRequest", "fields": [{"default": null, "doc": "",
"type": ["null", "string"], "name": "referenceSetId"}, {"default":
null, "doc": "", "type": ["null", "string"], "name": "variantSetId"},
{"default": null, "doc": "", "type": ["null", "int"], "name":
"pageSize"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "pageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'pageSize', 'pageToken', 'referenceSetId', 'variantSetId'
    ]

    def __init__(self, **kwargs):
        self.pageSize = kwargs.get(
            'pageSize', None)
        """
        Specifies the maximum number of results to return in a single
        page.   If unspecified, a system default will be used.
        """
        self.pageToken = kwargs.get(
            'pageToken', None)
        """
        The continuation token, which is used to page through large
        result sets.   To get the next page of results, set this
        parameter to the value of   nextPageToken from the previous
        response.
        """
        self.referenceSetId = kwargs.get(
            'referenceSetId', None)
        """
        If not null, return only Sequences that appear in the
        indicated   ReferenceSet, or any included ReferenceSets.    If
        null, variantSetId must not be null.
        """
        self.variantSetId = kwargs.get(
            'variantSetId', None)
        """
        If not null, return only Sequences that are part of the
        indicated   VariantSet.    If null, referenceSetId must not be
        null.
        """


class SearchSequencesResponse(SearchResponse):
    """
    This is the response from POST /sequences/search expressed as
    JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchSequencesResponse", "fields": [{"default": [], "doc": "",
"type": {"items": {"namespace": "org.ga4gh.models", "type": "record",
"name": "Sequence", "fields": [{"doc": "", "type": "string", "name":
"id"}, {"doc": "", "type": "long", "name": "length"}], "doc": ""},
"type": "array"}, "name": "sequences"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "nextPageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])
    _valueListName = "sequences"

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'sequences': Sequence,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'sequences': Sequence,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'nextPageToken', 'sequences'
    ]

    def __init__(self, **kwargs):
        self.nextPageToken = kwargs.get(
            'nextPageToken', None)
        """
        The continuation token, which is used to page through large
        result sets.   Provide this value in a subsequent request to
        return the next page of   results. This field will be empty if
        there aren't any additional results.
        """
        self.sequences = kwargs.get(
            'sequences', [])
        """
        The list of matching Sequences.
        """


class SearchVariantSetSequencesRequest(SearchRequest):
    """
    This request maps to the body of POST
    /variantsets/{id}/sequences/search as JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchVariantSetSequencesRequest", "fields": [{"doc": "", "type":
"string", "name": "parentId"}, {"default": null, "doc": "", "type":
["null", "int"], "name": "pageSize"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "pageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "parentId",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'pageSize', 'pageToken', 'parentId'
    ]

    def __init__(self, **kwargs):
        self.pageSize = kwargs.get(
            'pageSize', None)
        """
        Specifies the maximum number of results to return in a single
        page.   If unspecified, a system default will be used.
        """
        self.pageToken = kwargs.get(
            'pageToken', None)
        """
        The continuation token, which is used to page through large
        result sets.   To get the next page of results, set this
        parameter to the value of   nextPageToken from the previous
        response.
        """
        self.parentId = kwargs.get(
            'parentId', None)
        """
        Return Segments describing novel sequences in the VariantSet
        that are joined onto the sequence with the specified ID.
        """


class SearchVariantSetSequencesResponse(SearchResponse):
    """
    This is the response from POST /variantsets/{id}/sequences/search
    expressed as JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchVariantSetSequencesResponse", "fields": [{"default": [], "doc":
"", "type": {"items": {"namespace": "org.ga4gh.models", "type":
"record", "name": "Segment", "fields": [{"doc": "", "type": {"doc":
"", "type": "record", "name": "Side", "fields": [{"doc": "", "type":
{"doc": "", "type": "record", "name": "Position", "fields":
[{"default": null, "doc": "", "type": ["null", "string"], "name":
"sequenceId"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "referenceName"}, {"doc": "", "type": "long",
"name": "position"}]}, "name": "base"}, {"doc": "", "type":
{"symbols": ["NEG_STRAND", "POS_STRAND"], "doc": "", "type": "enum",
"name": "Strand"}, "name": "strand"}]}, "name": "start"}, {"doc": "",
"type": "long", "name": "length"}], "doc": ""}, "type": "array"},
"name": "segments"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "nextPageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])
    _valueListName = "segments"

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'segments': Segment,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'segments': Segment,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'nextPageToken', 'segments'
    ]

    def __init__(self, **kwargs):
        self.nextPageToken = kwargs.get(
            'nextPageToken', None)
        """
        The continuation token, which is used to page through large
        result sets.   Provide this value in a subsequent request to
        return the next page of   results. This field will be empty if
        there aren't any additional results.
        """
        self.segments = kwargs.get(
            'segments', [])
        """
        The list of Segments for matching sequences from the novel
        sequence graph   for the VariantSet.
        """


class SearchVariantSetsRequest(SearchRequest):
    """
    This request maps to the body of POST /variantsets/search as JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchVariantSetsRequest", "fields": [{"doc": "", "type": "string",
"name": "datasetId"}, {"default": null, "doc": "", "type": ["null",
"int"], "name": "pageSize"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "pageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "datasetId",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'datasetId', 'pageSize', 'pageToken'
    ]

    def __init__(self, **kwargs):
        self.datasetId = kwargs.get(
            'datasetId', None)
        """
        The Dataset to search.
        """
        self.pageSize = kwargs.get(
            'pageSize', None)
        """
        Specifies the maximum number of results to return in a single
        page.   If unspecified, a system default will be used.
        """
        self.pageToken = kwargs.get(
            'pageToken', None)
        """
        The continuation token, which is used to page through large
        result sets.   To get the next page of results, set this
        parameter to the value of   nextPageToken from the previous
        response.
        """


class SearchVariantSetsResponse(SearchResponse):
    """
    This is the response from POST /variantsets/search expressed as
    JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchVariantSetsResponse", "fields": [{"default": [], "doc": "",
"type": {"items": {"namespace": "org.ga4gh.models", "type": "record",
"name": "VariantSet", "fields": [{"doc": "", "type": "string", "name":
"id"}, {"doc": "", "type": "string", "name": "datasetId"}, {"doc": "",
"type": "string", "name": "referenceSetId"}, {"default": [], "doc":
"", "type": {"items": {"doc": "", "type": "record", "name":
"VariantSetMetadata", "fields": [{"doc": "", "type": "string", "name":
"key"}, {"doc": "", "type": "string", "name": "value"}, {"doc": "",
"type": "string", "name": "id"}, {"doc": "", "type": "string", "name":
"type"}, {"doc": "", "type": "string", "name": "number"}, {"doc": "",
"type": "string", "name": "description"}, {"default": {}, "doc": "",
"type": {"values": {"items": "string", "type": "array"}, "type":
"map"}, "name": "info"}]}, "type": "array"}, "name": "metadata"}],
"doc": ""}, "type": "array"}, "name": "variantSets"}, {"default":
null, "doc": "", "type": ["null", "string"], "name":
"nextPageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])
    _valueListName = "variantSets"

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'variantSets': VariantSet,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'variantSets': VariantSet,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'nextPageToken', 'variantSets'
    ]

    def __init__(self, **kwargs):
        self.nextPageToken = kwargs.get(
            'nextPageToken', None)
        """
        The continuation token, which is used to page through large
        result sets.   Provide this value in a subsequent request to
        return the next page of   results. This field will be empty if
        there aren't any additional results.
        """
        self.variantSets = kwargs.get(
            'variantSets', [])
        """
        The list of matching variant sets.
        """


class SearchVariantsRequest(SearchRequest):
    """
    This request maps to the body of POST /variants/search as JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchVariantsRequest", "fields": [{"doc": "", "type": "string",
"name": "variantSetId"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "name"}, {"default": null, "doc": "", "type":
["null", {"items": "string", "type": "array"}], "name": "callSetIds"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"referenceName"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "referenceId"}, {"doc": "", "type": "long", "name":
"start"}, {"doc": "", "type": "long", "name": "end"}, {"default":
null, "doc": "", "type": ["null", "int"], "name": "pageSize"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"pageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "end",
        "start",
        "variantSetId",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'callSetIds', 'end', 'name', 'pageSize', 'pageToken',
        'referenceId', 'referenceName', 'start', 'variantSetId'
    ]

    def __init__(self, **kwargs):
        self.callSetIds = kwargs.get(
            'callSetIds', None)
        """
        Only return variant calls which belong to call sets with these
        IDs.   If an empty array, returns variants without any call
        objects.   If null, returns all variant calls.
        """
        self.end = kwargs.get(
            'end', None)
        """
        Required. The end of the window (0-based, exclusive) for which
        variants with   overlapping reference alleles should be
        returned.
        """
        self.name = kwargs.get(
            'name', None)
        """
        Only return variants which have exactly this name (case-
        sensitive, exact match).
        """
        self.pageSize = kwargs.get(
            'pageSize', None)
        """
        Specifies the maximum number of results to return in a single
        page.   If unspecified, a system default will be used.
        """
        self.pageToken = kwargs.get(
            'pageToken', None)
        """
        The continuation token, which is used to page through large
        result sets.   To get the next page of results, set this
        parameter to the value of   nextPageToken from the previous
        response.
        """
        self.referenceId = kwargs.get(
            'referenceId', None)
        """
        Only return variants with reference alleles on the reference
        with this ID. One   of this field or referenceName is
        required.
        """
        self.referenceName = kwargs.get(
            'referenceName', None)
        """
        Only return variants with reference alleles on the reference
        with this name.   One of this field or referenceId is
        required.  (case-sensitive, exact match)
        """
        self.start = kwargs.get(
            'start', None)
        """
        Required. The beginning of the window (0-based, inclusive) for
        which variants with overlapping reference alleles should be
        returned.   Genomic positions are non-negative integers less
        than reference length.   Requests spanning the join of
        circular genomes are represented as   two requests one on each
        side of the join (position 0).
        """
        self.variantSetId = kwargs.get(
            'variantSetId', None)
        """
        The VariantSet to search.
        """


class SearchVariantsResponse(SearchResponse):
    """
    This is the response from POST /variants/search expressed as JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchVariantsResponse", "fields": [{"default": [], "doc": "",
"type": {"items": {"namespace": "org.ga4gh.models", "type": "record",
"name": "Variant", "fields": [{"doc": "", "type": "string", "name":
"id"}, {"doc": "", "type": "string", "name": "variantSetId"},
{"default": [], "doc": "", "type": {"items": "string", "type":
"array"}, "name": "names"}, {"default": null, "doc": "", "type":
["null", "long"], "name": "created"}, {"default": null, "doc": "",
"type": ["null", "long"], "name": "updated"}, {"default": null, "doc":
"", "type": ["null", "string"], "name": "referenceName"}, {"default":
null, "doc": "", "type": ["null", "long"], "name": "start"},
{"default": null, "doc": "", "type": ["null", "long"], "name": "end"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"referenceBases"}, {"default": null, "doc": "", "type": ["null",
{"items": "string", "type": "array"}], "name": "alternateBases"},
{"doc": "", "type": ["null", {"items": "string", "type": "array"}],
"name": "alleleIds"}, {"default": {}, "doc": "", "type": {"values":
{"items": "string", "type": "array"}, "type": "map"}, "name": "info"},
{"default": null, "doc": "", "type": ["null", {"items": {"doc": "",
"type": "record", "name": "Call", "fields": [{"doc": "", "type":
["null", "string"], "name": "callSetId"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "callSetName"}, {"doc": "",
"type": ["null", "string"], "name": "variantId"}, {"default": [],
"doc": "", "type": {"items": "int", "type": "array"}, "name":
"genotype"}, {"default": null, "doc": "", "type": ["null", "string",
{"items": "string", "type": "array"}], "name": "phaseset"},
{"default": [], "doc": "", "type": {"items": "double", "type":
"array"}, "name": "genotypeLikelihood"}, {"default": {}, "doc": "",
"type": {"values": {"items": "string", "type": "array"}, "type":
"map"}, "name": "info"}]}, "type": "array"}], "name": "calls"}],
"doc": ""}, "type": "array"}, "name": "variants"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "nextPageToken"}],
"doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])
    _valueListName = "variants"

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'variants': Variant,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'variants': Variant,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'nextPageToken', 'variants'
    ]

    def __init__(self, **kwargs):
        self.nextPageToken = kwargs.get(
            'nextPageToken', None)
        """
        The continuation token, which is used to page through large
        result sets.   Provide this value in a subsequent request to
        return the next page of   results. This field will be empty if
        there aren't any additional results.
        """
        self.variants = kwargs.get(
            'variants', [])
        """
        The list of matching variants.   If the callSetId field on the
        returned calls is not present,   the ordering of the call sets
        from a SearchCallSetsRequest   over the parent VariantSet is
        guaranteed to match the ordering   of the calls on each
        Variant. The number of results will also be   the same.
        """


class Segment(ProtocolElement):
    """
    A Segment is a range on a Sequence. It does not include any base
    data. (The bases for a Sequence are available through the
    getSequenceBases() API call.)  In the sequence "GTGG", the Segment
    starting at index 1 on the forward strand with length 2 is the
    "TG" on the forward strand. The length-2 Segment starting at index
    1 on the reverse strand is "AC", corresponding to the first two
    base pairs of the sequence, or the last two bases of the reverse
    complement.  A Segment has a left and a right end, in its local
    orientation (i.e. taking Segment.start.strand to be the Segment's
    forward strand).
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name": "Segment",
"fields": [{"doc": "", "type": {"doc": "", "type": "record", "name":
"Side", "fields": [{"doc": "", "type": {"doc": "", "type": "record",
"name": "Position", "fields": [{"default": null, "doc": "", "type":
["null", "string"], "name": "sequenceId"}, {"default": null, "doc":
"", "type": ["null", "string"], "name": "referenceName"}, {"doc": "",
"type": "long", "name": "position"}]}, "name": "base"}, {"doc": "",
"type": {"symbols": ["NEG_STRAND", "POS_STRAND"], "doc": "", "type":
"enum", "name": "Strand"}, "name": "strand"}]}, "name": "start"},
{"doc": "", "type": "long", "name": "length"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "length",
        "start",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'start': Side,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'start': Side,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'length', 'start'
    ]

    def __init__(self, **kwargs):
        self.length = kwargs.get(
            'length', None)
        """
        The length of this Segment's sequence. If start is on the
        forward strand,   the Segment contains the range
        [start.base.position,   start.base.position + length). If
        start is on the reverse strand, the   Segment contains the
        range (start.base.position - length,   start.base.position].
        This is equivalent to starting from the side indicated   by
        start, and traversing through that base out to the specified
        length.    A Segment may have zero length (for example, when
        it is being used to   specify a Path consisting only of a
        Join.
        """
        self.start = kwargs.get(
            'start', None)
        """
        The sequence ID and start index of this Segment. This base is
        the first   included in the Segment, regardless of
        orientation.
        """


class Sequence(ProtocolElement):
    """
    Represents a sequence in a sequence graph. May be joined onto
    parent Sequence(s) at the left and/or right endpoints, and may
    have other Sequences as children.  Does not include any base data.
    The bases for a Sequence are available through the
    getSequenceBases() API call.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"Sequence", "fields": [{"doc": "", "type": "string", "name": "id"},
{"doc": "", "type": "long", "name": "length"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "id",
        "length",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'id', 'length'
    ]

    def __init__(self, **kwargs):
        self.id = kwargs.get(
            'id', None)
        """
        The ID of the sequence.
        """
        self.length = kwargs.get(
            'length', None)
        """
        The length of the sequence. Must be greater than 0.
        """


class Side(ProtocolElement):
    """
    A Side is an oriented base in some already known sequence. A Side
    is represented by a sequence name or ID, a base number on that
    sequence (0-based), and a Strand to indicate the forward or
    reverse-complement orientation.  For example, given the sequence
    "GTGG", the Side on that sequence at offset 1 in the forward
    orientation would be the left side of the T/A base pair. The base
    at this Side is "T". Alternately, for offset 1 in the reverse
    orientation, the Side would be the right side of the T/A base
    pair, and the base at the Side is "A".  Offsets added to a Side
    are interpreted as reading along its strand; adding to a reverse
    strand side actually subtracts from its base.position member.
    There is a total ordering on sides, assuming a total ordering on
    Sequences. Sides are sorted by their Sequence (as specified by
    sequenceId and/or referenceName), then within a Sequence by their
    position offsets, and then finally by Strand, with NEG_STRAND
    first, then POS_STRAND.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name": "Side",
"fields": [{"doc": "", "type": {"doc": "", "type": "record", "name":
"Position", "fields": [{"default": null, "doc": "", "type": ["null",
"string"], "name": "sequenceId"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "referenceName"}, {"doc": "", "type":
"long", "name": "position"}]}, "name": "base"}, {"doc": "", "type":
{"symbols": ["NEG_STRAND", "POS_STRAND"], "doc": "", "type": "enum",
"name": "Strand"}, "name": "strand"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "base",
        "strand",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'base': Position,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'base': Position,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'base', 'strand'
    ]

    def __init__(self, **kwargs):
        self.base = kwargs.get(
            'base', None)
        """
        Base the Side is associated with.
        """
        self.strand = kwargs.get(
            'strand', None)
        """
        Strand the side is associated with. POS_STRAND represents the
        forward   strand, or equivalently the left side of a base, and
        NEG_STRAND represents   the reverse strand, or equivalently
        the right side of a base.    If you need a Side without a
        Strand, you need a Position.
        """


class Strand(object):
    """
    Indicates the DNA strand associate for some data item. *
    NEG_STRAND: The negative (-) strand. * POS_STRAND:  The postive
    (+) strand.
    """
    NEG_STRAND = "NEG_STRAND"
    POS_STRAND = "POS_STRAND"


class Variant(ProtocolElement):
    """
    A Variant represents a change in DNA sequence relative to some
    reference. For example, a variant could represent a SNP or an
    insertion. Variants belong to a VariantSet. This is equivalent to
    a row in VCF.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name": "Variant",
"fields": [{"doc": "", "type": "string", "name": "id"}, {"doc": "",
"type": "string", "name": "variantSetId"}, {"default": [], "doc": "",
"type": {"items": "string", "type": "array"}, "name": "names"},
{"default": null, "doc": "", "type": ["null", "long"], "name":
"created"}, {"default": null, "doc": "", "type": ["null", "long"],
"name": "updated"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "referenceName"}, {"default": null, "doc": "",
"type": ["null", "long"], "name": "start"}, {"default": null, "doc":
"", "type": ["null", "long"], "name": "end"}, {"default": null, "doc":
"", "type": ["null", "string"], "name": "referenceBases"}, {"default":
null, "doc": "", "type": ["null", {"items": "string", "type":
"array"}], "name": "alternateBases"}, {"doc": "", "type": ["null",
{"items": "string", "type": "array"}], "name": "alleleIds"},
{"default": {}, "doc": "", "type": {"values": {"items": "string",
"type": "array"}, "type": "map"}, "name": "info"}, {"default": null,
"doc": "", "type": ["null", {"items": {"doc": "", "type": "record",
"name": "Call", "fields": [{"doc": "", "type": ["null", "string"],
"name": "callSetId"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "callSetName"}, {"doc": "", "type": ["null",
"string"], "name": "variantId"}, {"default": [], "doc": "", "type":
{"items": "int", "type": "array"}, "name": "genotype"}, {"default":
null, "doc": "", "type": ["null", "string", {"items": "string",
"type": "array"}], "name": "phaseset"}, {"default": [], "doc": "",
"type": {"items": "double", "type": "array"}, "name":
"genotypeLikelihood"}, {"default": {}, "doc": "", "type": {"values":
{"items": "string", "type": "array"}, "type": "map"}, "name":
"info"}]}, "type": "array"}], "name": "calls"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "alleleIds",
        "id",
        "variantSetId",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'alleleIds', 'alternateBases', 'calls', 'created', 'end',
        'id', 'info', 'names', 'referenceBases', 'referenceName',
        'start', 'updated', 'variantSetId'
    ]

    def __init__(self, **kwargs):
        self.alleleIds = kwargs.get(
            'alleleIds', None)
        """
        The IDs of the reference and alternate Alleles for this
        Variant. The first   is the reference allele, and any others
        are alternates. If this field is set   along with
        referenceName, start, end, referenceBases, and/or
        alternateBases, those fields must agree with the Alleles given
        here.    If the API server supports the "graph" mode, this
        field must not be null.
        """
        self.alternateBases = kwargs.get(
            'alternateBases', None)
        """
        The bases that appear instead of the reference bases. If this
        field is not   null, referenceBases must be set.    If the API
        server supports the "classic" mode, this field must not be
        null.
        """
        self.calls = kwargs.get(
            'calls', None)
        """
        The variant calls for this particular variant. Each one
        represents the   determination of genotype with respect to
        this variant. Calls in this array   are implicitly associated
        with this Variant.    Calls are also available through the
        searchCalls() API method.    If the API server supports the
        "classic" mode, this field must not be null.
        """
        self.created = kwargs.get(
            'created', None)
        """
        The date this variant was created in milliseconds from the
        epoch.
        """
        self.end = kwargs.get(
            'end', None)
        """
        The end position (exclusive), resulting in [start, end)
        closed-open interval.   This is typically calculated by start
        + referenceBases.length.    If the API server supports the
        "classic" mode, this field must not be null.
        """
        self.id = kwargs.get(
            'id', None)
        """
        The variant ID.
        """
        self.info = kwargs.get(
            'info', {})
        """
        A map of additional variant information.
        """
        self.names = kwargs.get(
            'names', [])
        """
        Names for the variant, for example a RefSNP ID.
        """
        self.referenceBases = kwargs.get(
            'referenceBases', None)
        """
        The reference bases for this variant. They occupy the range
        described by   referenceName, start, and end, which all must
        be set if this field is   set.    If the API server supports
        the "classic" mode, this field must not be null.
        """
        self.referenceName = kwargs.get(
            'referenceName', None)
        """
        The reference on which this variant occurs.   (e.g. chr20 or
        X)    If the API server supports the "classic" mode, this
        field must not be null.
        """
        self.start = kwargs.get(
            'start', None)
        """
        The start position at which this variant occurs (0-based).
        This corresponds to the first base of the string of reference
        bases.   Genomic positions are non-negative integers less than
        reference length.   Variants spanning the join of circular
        genomes are represented as   two variants one on each side of
        the join (position 0).    If the API server supports the
        "classic" mode, this field must not be null.
        """
        self.updated = kwargs.get(
            'updated', None)
        """
        The time at which this variant was last updated in
        milliseconds from the epoch.
        """
        self.variantSetId = kwargs.get(
            'variantSetId', None)
        """
        The ID of the variant set this variant belongs to.
        """


class VariantSet(ProtocolElement):
    """
    Variant and CallSet both belong to a VariantSet. VariantSet
    belongs to a Dataset. The variant set is equivalent to a VCF file.
    A VariantSet can contain novel Sequences, which are used to
    augment the sequence graph of its ReferenceSet, creating the
    augmented sequence graph against which Alleles are interpreted.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"VariantSet", "fields": [{"doc": "", "type": "string", "name": "id"},
{"doc": "", "type": "string", "name": "datasetId"}, {"doc": "",
"type": "string", "name": "referenceSetId"}, {"default": [], "doc":
"", "type": {"items": {"doc": "", "type": "record", "name":
"VariantSetMetadata", "fields": [{"doc": "", "type": "string", "name":
"key"}, {"doc": "", "type": "string", "name": "value"}, {"doc": "",
"type": "string", "name": "id"}, {"doc": "", "type": "string", "name":
"type"}, {"doc": "", "type": "string", "name": "number"}, {"doc": "",
"type": "string", "name": "description"}, {"default": {}, "doc": "",
"type": {"values": {"items": "string", "type": "array"}, "type":
"map"}, "name": "info"}]}, "type": "array"}, "name": "metadata"}],
"doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "datasetId",
        "id",
        "referenceSetId",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'metadata': VariantSetMetadata,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'metadata': VariantSetMetadata,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'datasetId', 'id', 'metadata', 'referenceSetId'
    ]

    def __init__(self, **kwargs):
        self.datasetId = kwargs.get(
            'datasetId', None)
        """
        The ID of the dataset this variant set belongs to.
        """
        self.id = kwargs.get(
            'id', None)
        """
        The variant set ID.
        """
        self.metadata = kwargs.get(
            'metadata', [])
        """
        The metadata associated with this variant set. This is
        equivalent to   the VCF header information not already
        presented in first class fields.
        """
        self.referenceSetId = kwargs.get(
            'referenceSetId', None)
        """
        The reference set the variants in this variant set are using.
        """


class VariantSetMetadata(ProtocolElement):
    """
    This metadata represents VCF header information.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"VariantSetMetadata", "fields": [{"doc": "", "type": "string", "name":
"key"}, {"doc": "", "type": "string", "name": "value"}, {"doc": "",
"type": "string", "name": "id"}, {"doc": "", "type": "string", "name":
"type"}, {"doc": "", "type": "string", "name": "number"}, {"doc": "",
"type": "string", "name": "description"}, {"default": {}, "doc": "",
"type": {"values": {"items": "string", "type": "array"}, "type":
"map"}, "name": "info"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "description",
        "id",
        "key",
        "number",
        "type",
        "value",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'description', 'id', 'info', 'key', 'number', 'type', 'value'
    ]

    def __init__(self, **kwargs):
        self.description = kwargs.get(
            'description', None)
        """
        A textual description of this metadata.
        """
        self.id = kwargs.get(
            'id', None)
        """
        User-provided ID field, not enforced by this API.   Two or
        more pieces of structured metadata with identical   id and key
        fields are considered equivalent.
        """
        self.info = kwargs.get(
            'info', {})
        """
        Remaining structured metadata key-value pairs.
        """
        self.key = kwargs.get(
            'key', None)
        """
        The top-level key.
        """
        self.number = kwargs.get(
            'number', None)
        """
        The number of values that can be included in a field described
        by this   metadata.
        """
        self.type = kwargs.get(
            'type', None)
        """
        The type of data.
        """
        self.value = kwargs.get(
            'value', None)
        """
        The value field for simple metadata.
        """


class Wiggle(ProtocolElement):
    """
    Continuous numerical annotation along a path.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name": "Wiggle",
"fields": [{"default": null, "doc": "", "type": ["null", "string"],
"name": "referenceName"}, {"default": null, "doc": "", "type":
["null", "long"], "name": "start"}, {"default": null, "doc": "",
"type": ["null", "long"], "name": "end"}, {"default": [], "doc": "",
"type": {"items": "float", "type": "array"}, "name": "values"}],
"doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'end', 'referenceName', 'start', 'values'
    ]

    def __init__(self, **kwargs):
        self.end = kwargs.get(
            'end', None)
        """
        The end position (exclusive), resulting in [start, end)
        closed-open interval.     This is typically calculated by
        start + referenceBases.length.      If the API server supports
        the "classic" mode, this field must not be null.
        """
        self.referenceName = kwargs.get(
            'referenceName', None)
        """
        The reference on which this feature occurs.     (e.g. chr20 or
        X)      If the API server supports the "classic" mode, this
        field must not be null.
        """
        self.start = kwargs.get(
            'start', None)
        """
        The start position at which this feature occurs (0-based).
        This corresponds to the first base of the string of reference
        bases.     Genomic positions are non-negative integers less
        than reference length.     Features spanning the join of
        circular genomes are represented as     two features one on
        each side of the join (position 0).      If the API server
        supports the "classic" mode, this field must not be null.
        """
        self.values = kwargs.get(
            'values', [])
        """
        The values associated to this region.     If this list
        contains _count_ elements, then the region is divided     as
        cleanly as possible into _count_ bins of equal width.     We
        thus define a numerical function:      value(position):
        if position < start or position >= start + length:
        return None       else:         return array[floor((position -
        start)*count/length)]
        """


class WiggleSet(ProtocolElement):
    """
    No documentation
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"WiggleSet", "fields": [{"doc": "", "type": "string", "name": "id"},
{"doc": "", "type": {"doc": "", "type": "record", "name":
"Attributes", "fields": [{"default": {}, "type": {"values": {"items":
["string", {"doc": "", "type": "record", "name": "ExternalIdentifier",
"fields": [{"doc": "", "type": "string", "name": "database"}, {"doc":
"", "type": "string", "name": "identifier"}, {"doc": "", "type":
"string", "name": "version"}]}, {"doc": "", "type": "record", "name":
"OntologyTerm", "fields": [{"doc": "", "type": "string", "name":
"ontologySource"}, {"doc": "", "type": "string", "name": "id"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"name"}]}], "type": "array"}, "type": "map"}, "name": "vals"}]},
"name": "attributes"}]}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "attributes",
        "id",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'attributes': Attributes,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'attributes': Attributes,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'attributes', 'id'
    ]

    def __init__(self, **kwargs):
        self.attributes = kwargs.get(
            'attributes', None)
        """
        Set of additional attributes
        """
        self.id = kwargs.get(
            'id', None)
        """
        Id of this annotation node.
        """

postMethods = \
    [('/alleles/search',
      SearchAllelesRequest,
      SearchAllelesResponse),
     ('/analyses/search',
      SearchAnalysesRequest,
      SearchAnalysesResponse),
     ('/callsets/search',
      SearchCallSetsRequest,
      SearchCallSetsResponse),
     ('/datasets/search',
      SearchDatasetsRequest,
      SearchDatasetsResponse),
     ('/experiments/search',
      SearchExperimentsRequest,
      SearchExperimentsResponse),
     ('/expressionlevel/search',
      SearchExpressionLevelRequest,
      SearchExpressionLevelResponse),
     ('/featuregroup/search',
      SearchFeatureGroupRequest,
      SearchFeatureGroupResponse),
     ('/features/search',
      SearchFeaturesRequest,
      SearchFeaturesResponse),
     ('/individualgroups/search',
      SearchIndividualGroupsRequest,
      SearchIndividualGroupsResponse),
     ('/individuals/search',
      SearchIndividualsRequest,
      SearchIndividualsResponse),
     ('/joins/search',
      SearchJoinsRequest,
      SearchJoinsResponse),
     ('/readgroupsets/search',
      SearchReadGroupSetsRequest,
      SearchReadGroupSetsResponse),
     ('/reads/search',
      SearchReadsRequest,
      SearchReadsResponse),
     ('/references/search',
      SearchReferencesRequest,
      SearchReferencesResponse),
     ('/referencesets/search',
      SearchReferenceSetsRequest,
      SearchReferenceSetsResponse),
     ('/rnaquantification/search',
      SearchRnaQuantificationRequest,
      SearchRnaQuantificationResponse),
     ('/samples/search',
      SearchSamplesRequest,
      SearchSamplesResponse),
     ('/sequences/search',
      SearchSequencesRequest,
      SearchSequencesResponse),
     ('/variants/search',
      SearchVariantsRequest,
      SearchVariantsResponse),
     ('/variantsets/search',
      SearchVariantSetsRequest,
      SearchVariantSetsResponse),
     ('/variantsetsequences/search',
      SearchVariantSetSequencesRequest,
      SearchVariantSetSequencesResponse)]
